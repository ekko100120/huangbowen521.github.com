<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Gradle | 黄博文的地盘]]></title>
  <link href="http://www.huangbowen.net/blog/tags/gradle/atom.xml" rel="self"/>
  <link href="http://www.huangbowen.net/"/>
  <updated>2014-08-28T00:56:01+10:00</updated>
  <id>http://www.huangbowen.net/</id>
  <author>
    <name><![CDATA[黄博文]]></name>
    <email><![CDATA[huangbowen521@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gradle与Gatling脚本集成]]></title>
    <link href="http://www.huangbowen.net/blog/2014/07/23/integrate-gatling-with-gradle/"/>
    <updated>2014-07-23T16:12:23+10:00</updated>
    <id>http://www.huangbowen.net/blog/2014/07/23/integrate-gatling-with-gradle</id>
    <content type="html"><![CDATA[<p>Gatling作为次时代的性能测试工具，由于其API简洁明了、性能出众，越来越受欢迎。但是运行Gatling脚本却有诸多不便，其提供的默认方式不是很方便。考虑到Gatling脚本本质上是Scala类，运行的时候还是使用的是java虚拟机，我们可以将其脚本的运行与Gradle结合起来。这样子就可以通过Gradle来运行Gatling脚本了。</p>

<!-- more -->


<p>废话少说，接下来就讲述下如何来进行配置。</p>

<p>创建一个标准的maven结构的工程目录，如下图所示。</p>

<p><img src="/images/gradle-gatling.png" width="600"></p>

<p>conf目录存放Gatling的基本配置文件。
Gatling的脚本文件存放在src/test/scala/simulations包里面。可以自行在此包下对脚本文件再分类。</p>

<p>在build.gradle文件中引入scala插件。</p>

<pre><code class="groovy">
apply plugin: 'scala'
</code></pre>

<p>然后引入有gatling库的maven repo。</p>

<pre><code class="groovy">
repositories {
    mavenCentral ()
    maven {
        url 'http://repository.excilys.com/content/groups/public'
    }
}
</code></pre>

<p>再加入scala和gatling的依赖项。</p>

<pre><code class="groovy">
dependencies {
    compile 'org.scala-lang:scala-library:2.10.1'
    testCompile 'io.gatling.highcharts:gatling-charts-highcharts:2.0.0-M3a'
}
</code></pre>

<p>把conf文件夹作为test的source文件。</p>

<pre><code class="groovy">
sourceSets {
    test {
        resources {
            srcDir 'conf'
        }
    }
}
</code></pre>

<p>创建一个名为gatling的task，目的是运行所有的gatling脚本。</p>

<pre><code class="groovy">
task gatling (dependsOn: 'compileTestScala') &lt;&lt; {

    logger.lifecycle (" ---- Executing all Gatling scenarios from: ${sourceSets.test.output.classesDir} ----")

    sourceSets.test.output.classesDir.eachFileRecurse { file -&gt;
        if (file.isFile ()) {

            def gatlingScenarioClass = (file.getPath () - (sourceSets.test.output.classesDir.getPath () + File.separator) - '.class')
                    .replace (File.separator, '.')

            javaexec {
                main = 'io.gatling.app.Gatling'
                classpath = sourceSets.test.output + sourceSets.test.runtimeClasspath
                args '-sbf',
                        sourceSets.test.output.classesDir,
                        '-s',
                        gatlingScenarioClass,
                        '-rf',
                        'build/reports/gatling'
            }
        }

    }

    logger.lifecycle (" ---- Done executing all Gatling scenarios ----")
}
</code></pre>

<p>这是借助于Gatling的command line运行功能来实现的。具体参数指定官网上有，这里贴出原文。</p>

<blockquote><p>Command Line Options #
Gatling can be started with several options listed below:</p></blockquote>

<ul>
<li> -nr (&ndash;no-reports): Runs simulation but does not generate reports</li>
<li> -ro <folderName> (&ndash;reports-only <folderName>): Generates the reports for the simulation log file located in <gatling_home>/results/<folderName></li>
<li> -df <folderAbsolutePath> (&ndash;data-folder <folderAbsolutePath>): Uses <folderAbsolutePath> as the folder where feeders are stored</li>
<li> -rf <folderAbsolutePath> (&ndash;results-folder <folderAbsolutePath>): Uses <folderAbsolutePath> as the folder where results are stored</li>
<li> -bf <folderAbsolutePath> (&ndash;request-bodies-folder <folderAbsolutePath>): Uses <folderAbsolutePath> as the folder where request bodies are stored</li>
<li> -sf <folderAbsolutePath> (&ndash;simulations-folder <folderAbsolutePath>): Uses <folderAbsolutePath> as the folder where simulations are stored</li>
<li> -sbf <folderAbsolutePath> (&ndash;simulations-binaries-folder <folderAbsolutePath>): Uses <folderAbsolutePath> as the folder where simulation binaries are stored</li>
<li> -s <className> (&ndash;simulation <className>): Uses <className> as the name of the simulation to be run</li>
<li> -sd <text> (&ndash;simulation-description <text>): Uses <text> as simulation description</li>
</ul>


<p>我在github上创建了一个示例项目，请参见<a href="https://github.com/huangbowen521/gatling-gradle">https://github.com/huangbowen521/gatling-gradle</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Gradle运行集成测试]]></title>
    <link href="http://www.huangbowen.net/blog/2013/12/10/integration-test-in-gradle/"/>
    <updated>2013-12-10T13:17:00+10:00</updated>
    <id>http://www.huangbowen.net/blog/2013/12/10/integration-test-in-gradle</id>
    <content type="html"><![CDATA[<p>如果Gradle构建的项目是一个web项目的话，里面可能包含一些集成测试和功能性测试。这些测试和单元测试不同之处是在运行之前要先在本地将web服务启动起来，并且跑完测试后能够自动的关闭web服务。</p>

<!-- more -->


<p>在本地启动web服务我们可以使用Gradle内置的jetty插件。jetty是一个轻量级的web容器，其执行速度快，配置简单，远程调试方便。启用jetty只需在build.gradle中加入对这个插件的引用。</p>

<pre><code class="groovy build.gradle">
apply plugin: 'jetty'
</code></pre>

<p>之后可以配置war包的名称，启动的端口等属性。</p>

<pre><code class="groovy build.gradle">
apply plugin: 'jetty'

httpPort = 9876

[jettyRun, jettyRunWar, jettyStop]*.stopPort = 9966
[jettyRun, jettyRunWar, jettyStop]*.stopKey = 'stopKey'
</code></pre>

<p>我们需要将集成测试与一般的单元测试分开。因为单元测试并不需要事先启动web服务，保证其执行速度快，能够得到更快的反馈。一般做法是单元测试后缀名为Test.java，集成测试后缀名为IntegrationTest.java。</p>

<p>配置单元测试执行的测试集合。</p>

<pre><code class="groovy build.gradle">
test {
    include '**/*Test.class'
    exclude '**/*IntegrationTest.class'
}
</code></pre>

<p>然后新建一个Task，用于运行集成测试。</p>

<pre><code class="groovy build.gradle">
task intTest(type: Test, dependsOn: test) {

    include '**/*IntegrationTest.class'

    doFirst {

        jettyRun.daemon = true
        jettyRun.execute()

    }

    doLast {
        jettyStop.execute()
    }
}
</code></pre>

<p>上述代码首先是创建一个名为intTest的task，其类型为Test,依赖于test task。该集成测试只会运行后缀名为IntegrationTest的测试类。在运行测试之前，首先采用后台模式启动jetty服务器，运行完测试后再调用jettyStop task停止jetty服务。</p>

<p>为了使我们在运行<code>gradle build</code>时也会运行intTest task，可以添加对intTest的依赖。</p>

<pre><code class="groovy build.gradle">
build.dependsOn intTest
</code></pre>

<p>这样在运行<code>gradle build</code>时也会运行集成测试。并且在集成测试前后web服务会自动的启动和关闭。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gradle中使用idea插件的一些实践]]></title>
    <link href="http://www.huangbowen.net/blog/2013/12/04/use-idea-plugin-in-gradle/"/>
    <updated>2013-12-04T22:19:00+10:00</updated>
    <id>http://www.huangbowen.net/blog/2013/12/04/use-idea-plugin-in-gradle</id>
    <content type="html"><![CDATA[<p>如果你的项目使用了Gradle作为构建工具，那么你一定要使用Gradle来自动生成IDE的项目文件，无需再手动的将源代码导入到你的IDE中去了。</p>

<!-- more -->


<p>如果你使用的是eclipse，可以在build.gradle中加入这么一行.</p>

<pre><code class="groovy">
apply plugin: 'eclipse'
</code></pre>

<p>然后在命令行中输入<code>gradle eclipse</code>就可以生成eclipse的项目文件，直接使用eclipse打开生成的项目文件即可。</p>

<p>当然作为Java程序开发者，最好使的IDE还是Intellij,昨天听闻Intellij 13已经发布了，增加了不少新功能，看来又要掏腰包了。如果要让Gradle自动生成Intellij的项目文件，需要使用idea插件。</p>

<pre><code class="groovy">
apply plugin: 'idea'
</code></pre>

<p>命令行下输入<code>gradle idea</code>，就会生成Intellij的项目文件，真是省时省力。如果在已经存在Intellij的项目文件情况下，想根据build.gradle中的配置来更新项目文件，可以输入<code>gradle cleanIdea idea</code>。<code>cleanIdea</code>可以清除已有的Intellij项目文件。</p>

<p>Intellij项目文件主要有三种类型。</p>

<ul>
<li><p>.ipr Intellij工程文件</p></li>
<li><p>.iml Intellij 模块文件</p></li>
<li><p>.iws Intellij 工作区文件</p></li>
</ul>


<p>如果只简单的使用<code>gradle idea</code>生成Intellij的工程文件，其实在使用Intellij打开项目以后，我们还要做一些手工配置，比如指定JDK的版本，指定源代码管理工具等。Gradle的idea命令本质上就是生成这三个xml文件,所以Gradle提供了生成文件时的hook(钩子)，让我们可以方便的做定制化，实现最大程度的自动化。这就需要自定义idea这个任务了。</p>

<pre><code class="groovy">
idea.project {
     jdkName = '1.6'
     languageLevel = '1.6' 
}
</code></pre>

<p>这个用来配置项目的jdk及languageLevel。</p>

<p>如果要指定源代码管理工具类型，就需要调用hook修改生成的ipr文件。</p>

<pre><code class="groovy">
idea.project {

    ipr {
        withXml { provider -&gt;
            provider.node.component.find { it.@name == 'VcsDirectoryMappings' }.mapping.@vcs = 'Git'
        }
    }

}
</code></pre>

<p>通过这种方式可以最大限度的实现对Intellij项目文件的定制化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gradle的属性设置大全]]></title>
    <link href="http://www.huangbowen.net/blog/2013/09/12/setup-properties-in-gradle/"/>
    <updated>2013-09-12T22:41:00+10:00</updated>
    <id>http://www.huangbowen.net/blog/2013/09/12/setup-properties-in-gradle</id>
    <content type="html"><![CDATA[<p>Gradle作为一款项目构建工具，由于其强大、灵活、快速、完全兼容Ant等特性，越来越受到人们欢迎。Gradle的灵活有时候也会引起人们的困惑。比如在Gradle中设置变量和属性就有N种办法。由于Gradle的理念是Convention over configruation(约定优于配置),所以如果了解了这些约定，那么在使用Gradle的属性配置时一定会如鱼得水。</p>

<!-- more -->


<hr />

<p><strong>在项目根目录下建立名为gradle.properties文件，在该文件中定义需要的属性。这些属性在Gradle构建Gradle领域对象（即project对象实例）时会被自动加到project对象实例中作为其属性被直接调用。</strong></p>

<pre><code class="xml gradle.properties">
guestName= Bowen 
</code></pre>

<pre><code class="groovy build.gradle">
task hello &lt;&lt; {
     println $guestName
     println "hello, $guestName"
}
</code></pre>

<pre><code class="bash">
$ gradle hello -q
Bowen
hello, Bowen

$ gradle properties | grep guestName
guestName: Bowen
</code></pre>

<hr />

<p><strong>定义在build.gradle中的ext块中。ext准确的说是Gradle领域对象的一个属性，我们可以将自定义的属性添加到ext对象上，Build.gradle中的其它代码片段可以使用。</strong></p>

<pre><code class="groovy build.gradle">
ext {
     guestName='Bowen'
}

task hello &lt;&lt; {
     println guestName
     println "hello, $guestName"
}
</code></pre>

<pre><code class="bash">
$ gradle hello -q
Bowen
hello, Bowen

$ gradle properties | grep guestName
guestName: Bowen
$ gradle properties | grep ext
ext: org.gradle.api.internal.plugins.DefaultExtraPropertiesExtension@10ef5fa0
</code></pre>

<p>从上述可以看到ext对象其实是DefaultExtraPropertiesExtension对象的一个实例。</p>

<hr />

<p><strong>在命令行中通过<code>-D</code>或者<code>-P</code>给Gradle实时创建属性。</strong>
<code>-D</code>属性会被传送给启动Gradle的jvm，作为一个系统属性被jvm使用。</p>

<pre><code class="groovy build.gradle">
task hello &lt;&lt; {
     println System.properties['guestName']
}
</code></pre>

<pre><code class="bash">
$ gradle hello -DguestName='Bowen' -q
Bowen
</code></pre>

<p><code>-P</code>属性则会被直接加载到Gradle领域对象上。</p>

<pre><code class="groovy build.gradle">
task hello &lt;&lt; {
      println "hello, $guestName"
}
</code></pre>

<pre><code class="bash">
$ gradle hello -PguestName='Bowen' -q
hello, Bowen
</code></pre>

<hr />

<p><strong>在Gradle配置文件中创建系统属性。刚讲过在gradle.properties文件可以创建属性，同时我们也可以创建系统属性。如果有<code>systemProp.</code>前缀的属性会被识别为系统属性。</strong></p>

<pre><code class="xml gradle.properties">
systemProp.guestName = 'Bowen' 
</code></pre>

<pre><code class="groovy build.gradle">
task hello &lt;&lt; {
      println "hello, " + System.properties['guestName']
}
</code></pre>

<pre><code class="bash">
$ gradle hello -q
hello, Bowen
</code></pre>

<hr />

<p><strong>将特殊前缀的系统属性或环境变量自动加入到Gradle领域对象中。</strong></p>

<p>如果有环境变量以<code>ORG_GRADLE_PROJECT.</code>为前缀，那么该变量会被自动添加到Gradle领域对象中。同样，如果有系统属性以<code>org.gradle.project.</code>为前缀，那么也会被自动加入到Gradl领域对象中。这一特性的目的之一是为了隐藏一些敏感的信息。比如在执行Gradle脚本时需要传入密码信息，如果以<code>-P</code>的方式传送会被别人看到。而把该属性保存为环境变量，只有系统管理员才有权访问和修改。在运行Gralde的时候该环境变量会被自动加入到Gradle对象中被使用，隔离了明暗数据，又不行影响其他用户使用。（其他用户可以通过<code>-P</code>方式是设置该属性）。</p>

<pre><code class="groovy build.gradle">
task hello &lt;&lt; {
      println "hello, " + guestName 
}
</code></pre>

<pre><code class="bash">
$ gradle hello -Dorg.gradle.project.guestName=Bowen -q
hello, Bowen

$ export ORG_GRADLE_PROJECT_guestName=Bob
$ gradle hello -q
hello, Bob
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gradle里配置jetty实现静态资源的热部署]]></title>
    <link href="http://www.huangbowen.net/blog/2013/09/04/hot-deploy-for-jetty-gradle-plugin/"/>
    <updated>2013-09-04T22:32:00+10:00</updated>
    <id>http://www.huangbowen.net/blog/2013/09/04/hot-deploy-for-jetty-gradle-plugin</id>
    <content type="html"><![CDATA[<p>通过Gradle我们可以很方便的使用内置jetty启动我们的web程序，在本地进行调试。但是在使用的过程中，我发现了几个问题，导致本地调试的效率大受影响。</p>

<!-- more -->


<ol>
<li><p>如果使用<code>gradle jettyRun</code>启动jetty服务器后，项目里的静态资源（jsp，html，JavaScript文件）都被锁定了，导致无法实时修改这些静态资源。</p></li>
<li><p>既然无法实时修改这些静态资源，那意味着我们做一个很小的改动都需要先停止jetty server，然后修改，再重新启动jetty server，这样来回浪费很多时间，尤其是涉及前台页面改动时，每调整一个参数都需要重启jetty。</p></li>
</ol>


<p>由于我以前使用过Maven，在Maven里jetty是可以显示热部署的。也就是说如果有静态文件被改动，那么jetty可以实时load并展现。那么在Gradle里面实现这个应该也不是难事，花了一些时间搞定了。</p>

<ul>
<li><strong>首先要解决文件被锁定的问题。</strong></li>
</ul>


<p>文件被锁定是由于在使用windows系统时，jetty默认在内存中映射了这些文件，而windows会锁定内存映射的文件。解决的办法就是修改jetty的配置，让其在启动server时将useFileMappedBuffer标志位设置为false。</p>

<p>设置方法有两种，一种是修改webdefault.xml文件中的useFileMappdBuffer标志位。webdefault.xml文件是jetty启动服务的配置文件，其先于项目中的WEB-INF/web.xml文件被加载。
jetty包中默认有这个文件，可以将其提取出来，保存在项目根目录下，并修改useFileMappedBuffer节点。</p>

<pre><code class="xml">
&lt;param-name&gt;useFileMappedBuffer&lt;/param-name&gt; 
&lt;param-value&gt;false&lt;/param-value&gt;
</code></pre>

<p>然后在build.gradle加入对此文件的引用。</p>

<pre><code class="groovy">
[jettyRun, jettyRunWar,jettyStop]*.with {    
    webDefaultXml = file("${rootDir}/webdefault.xml") 
}
</code></pre>

<p>第二种方法是修改项目中的<code>WEB-INF/web.xml</code>文件，在其中加入这个节点。</p>

<pre><code class="xml">
&lt;servlet&gt;
    &lt;!-- Override init parameter to avoid nasty --&gt;
    &lt;!-- file locking issue on windows.         --&gt; 
    &lt;servlet-name&gt;default&lt;/servlet-name&gt; 
        &lt;init-param&gt;    
            &lt;param-name&gt;useFileMappedBuffer&lt;/param-name&gt;  
            &lt;param-value&gt;false&lt;/param-value&gt; 
        &lt;/init-param&gt; 
&lt;/servlet&gt;
</code></pre>

<ul>
<li><strong>解决jetty的hot deploy的问题。</strong></li>
</ul>


<p>这个就比较简单了，Gradle的jetty插件有两个属性，一个是reload属性，需要设置为automatic。另一个属性是
scanIntervalSeconds，这是指定jetty扫描文件改变的时间间隔，默认为0，单位是秒。
在build.gradle中加入设置。</p>

<pre><code class="groovy">
jettyRun {    
    reload ="automatic"    
    scanIntervalSeconds = 1 
}
</code></pre>

<p>齐活。接下来运行<code>gradle jettyRun</code>，待服务启动起来以后，如果修改了静态资源，只需要按<code>Ctrl</code>+<code>R</code>刷新页面即可重新加载资源。</p>
]]></content>
  </entry>
  
</feed>
