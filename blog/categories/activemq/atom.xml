<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ActiveMQ | 黄博文的地盘]]></title>
  <link href="http://www.huangbowen.net/blog/categories/activemq/atom.xml" rel="self"/>
  <link href="http://www.huangbowen.net/"/>
  <updated>2014-03-13T02:18:15+10:00</updated>
  <id>http://www.huangbowen.net/</id>
  <author>
    <name><![CDATA[黄博文]]></name>
    <email><![CDATA[huangbowen521@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ActiveMQ第五弹:增加ReDelivery功能]]></title>
    <link href="http://www.huangbowen.net/blog/2014/03/10/use-redelivery-in-activemq/"/>
    <updated>2014-03-10T01:17:00+10:00</updated>
    <id>http://www.huangbowen.net/blog/2014/03/10/use-redelivery-in-activemq</id>
    <content type="html"><![CDATA[<p>在使用Message Queue的过程中，总会由于种种原因而导致消息失败。一个经典的场景是一个生成者向Queue中发消息，里面包含了一组邮件地址和邮件内容。而消费者从Queue中将消息一条条读出来，向指定邮件地址发送邮件。消费者在发送消息的过程中由于种种原因会导致失败，比如网络超时、当前邮件服务器不可用等。这样我们就希望建立一种机制，对于未发送成功的邮件再重新发送，也就是重新处理。重新处理超过一定次数还不成功，就放弃对该消息的处理，记录下来，继续对剩余消息进行处理。</p>

<!-- more -->


<p>ActiveMQ为我们实现了这一功能，叫做ReDelivery(重新投递)。当消费者在处理消息时有异常发生，会将消息重新放回Queue里，进行下一次处理。当超过重试次数时，消息会被放置到一个特殊的Queue中，即Dead Letter Queue,简称DLQ，用于进行后续分析。</p>

<p>废话不多说，一起来实现吧。（该示例中的全部代码已放置到<a href="https://github.com/huangbowen521/SpringJMSSample">GitHub</a>上，请自行下载。）</p>

<p>还是接着本系列中的示例代码来进行。要实现ReDelivery功能，要给LinsterContainer加上事务处理。设置SimpleMessageListenerContainer的sessionTransacted属性为true。</p>

<p>```xml activeMQConnection.xml</p>

<pre><code>&lt;!-- Message Receiver Definition --&gt;
&lt;bean id="messageReceiver" class="huangbowen.net.jms.retry.MessageReceiver"&gt;
&lt;/bean&gt;
&lt;bean class="org.springframework.jms.listener.SimpleMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destinationName" value="${jms.queue.name}"/&gt;
    &lt;property name="messageListener" ref="messageReceiver"/&gt;
    &lt;property name="sessionTransacted" value="true" /&gt;
&lt;/bean&gt;
</code></pre>

<p>```</p>

<p>然后创建一个ReDeliveryPolicy，来定义ReDelivery的机制。</p>

<p>```xml activeMQConnection.xml</p>

<pre><code>&lt;amq:redeliveryPolicy id="activeMQRedeliveryPolicy" destination="#defaultDestination" redeliveryDelay="100" maximumRedeliveries="4" /&gt;
</code></pre>

<p>```</p>

<p>这里设置ReDelivery的时间间隔是100毫秒，最大重发次数是4次。</p>

<p>在ActiveMQ的Connection Factory中应用这个Policy。就是给Connection Factory设置属性redeliveryPolicy为我们刚刚创建的Policy。</p>

<p>```xml activeMQConnection.xml</p>

<pre><code>&lt;!-- Activemq connection factory --&gt;
&lt;bean id="amqConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;
    &lt;property name="brokerURL" value="${jms.broker.url}?"/&gt;
    &lt;property name="useAsyncSend" value="true"/&gt;
    &lt;property name="redeliveryPolicy" ref="activeMQRedeliveryPolicy" /&gt;
&lt;/bean&gt;
</code></pre>

<p>```</p>

<p>这样ReDelivery机制就设置好了。那么怎么能证明我不是在忽悠你们那？当然最好的办法是写自动化测试来测试这个功能了。</p>

<p>首先修改下broker的配置，将其对消息的持久化设置为false，这样每次运行测试时Queue中消息都为0，用于还原现场。然后设置一个Destination Policy，当消息超过重试次数仍未被正确处理时，就把它放入到以<code>DLQ.</code>为前缀的Queue中。由于ActiveMQ默认对非持久化的Message不放入DLQ中的，所以手动设置processNonPersistent为true。</p>

<p>```xml activeMQConnection.xml</p>

<pre><code>&lt;amq:broker id="activeMQBroker" persistent="false"&gt;
    &lt;amq:transportConnectors&gt;
        &lt;amq:transportConnector uri="${jms.broker.url}"/&gt;
    &lt;/amq:transportConnectors&gt;
    &lt;amq:destinationPolicy&gt;
        &lt;amq:policyMap&gt;
            &lt;amq:policyEntries&gt;
                &lt;amq:policyEntry queue="&gt;"&gt;
                    &lt;amq:deadLetterStrategy&gt;
                        &lt;amq:individualDeadLetterStrategy
                                queuePrefix="DLQ." useQueueForQueueMessages="true" processExpired="true"
                                processNonPersistent="true" /&gt;
                    &lt;/amq:deadLetterStrategy&gt;
                &lt;/amq:policyEntry&gt;
            &lt;/amq:policyEntries&gt;
        &lt;/amq:policyMap&gt;
    &lt;/amq:destinationPolicy&gt;
&lt;/amq:broker&gt;
</code></pre>

<p>```</p>

<p>然后新建一个MessageListener，当接收到消息就抛出一个异常，这样用以启动ReDelivery机制。</p>

<p>```java retry/MessageReceiver</p>

<p>package huangbowen.net.jms.retry;</p>

<p>import org.springframework.jms.support.JmsUtils;</p>

<p>import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;</p>

<p>public class MessageReceiver implements MessageListener {</p>

<pre><code>public void onMessage(Message message) {
    if(message instanceof TextMessage) {
        TextMessage textMessage = (TextMessage) message;
        try {
            String text = textMessage.getText();
            System.out.println(String.format("Received: %s",text));
            throw new JMSException("process failed");
        } catch (JMSException e) {
            System.out.println("there is JMS exception: " + e.getMessage() );
            throw JmsUtils.convertJmsAccessException(e);
        }
    }
}
</code></pre>

<p>}</p>

<p>```</p>

<p>最后新建一个集成测试类。</p>

<p>```java ReDeliveryFunctionIntegrationTest.java</p>

<p>package huangbowen.net;</p>

<p>import huangbowen.net.jms.MessageSender;
import org.junit.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jms.core.BrowserCallback;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.AbstractJUnit4SpringContextTests;</p>

<p>import javax.jms.JMSException;
import javax.jms.QueueBrowser;
import javax.jms.Session;
import java.util.Enumeration;</p>

<p>import static org.hamcrest.core.Is.is;
import static org.junit.Assert.assertThat;</p>

<p>@ContextConfiguration(locations = {"/retry/activeMQConnection.xml"})
@DirtiesContext
public class ReDeliveryFunctionIntegrationTest extends AbstractJUnit4SpringContextTests {</p>

<pre><code>private final static String DLQ = "DLQ.bar";
@Autowired
public JmsTemplate jmsTemplate;

@Autowired
public MessageSender messageSender;


private int getMessagesInDLQ() {
    return jmsTemplate.browse(DLQ, new BrowserCallback&lt;Integer&gt;() {
        @Override
        public Integer doInJms(Session session, QueueBrowser browser) throws JMSException {
            Enumeration messages = browser.getEnumeration();
            int total = 0;
            while(messages.hasMoreElements()) {
                messages.nextElement();
                total++;
            }

            return  total;
        }
    });
}

@Test
public void shouldRetryIfExceptionHappened() throws Exception {

    assertThat(getMessagesInDLQ(), is(0));

    messageSender.send("this is a message");
    Thread.sleep(5000);

    assertThat(getMessagesInDLQ(), is(1));
}
</code></pre>

<p>}</p>

<p>```</p>

<p>我们通过Spring的Autowired功能拿到配置中的JmsTemplate和MessageSender。使用JmsTemplate的brower方法来读取当前DLQ.bar Queue中有多少剩余的消息。用MessageSender来发送一条消息，这样即使我们有Listener来处理这条消息，但是由于每次都会抛出异常，超过限定次数后，被放置到了DLQ.bar中。我们检测DLQ.bar中的消息数量就可以知道ReDelivery功能是否正确。</p>

<p>运行测试，成功通过。这是日志信息：</p>

<p>```text</p>

<p>send: this is a message
Received: this is a message
there is JMS exception: process failed
Received: this is a message
there is JMS exception: process failed
Received: this is a message
there is JMS exception: process failed
Received: this is a message
there is JMS exception: process failed
Received: this is a message
there is JMS exception: process failed</p>

<p>Process finished with exit code 0</p>

<p>```</p>

<p>本系列的全部示例代码请在<a href="https://github.com/huangbowen521/SpringJMSSample">https://github.com/huangbowen521/SpringJMSSample</a>下载。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveMQ第四弹:在HermesJMS中创建ActiveMQ session]]></title>
    <link href="http://www.huangbowen.net/blog/2014/02/23/configure-activemq-session-in-hermesjms/"/>
    <updated>2014-02-23T15:03:00+10:00</updated>
    <id>http://www.huangbowen.net/blog/2014/02/23/configure-activemq-session-in-hermesjms</id>
    <content type="html"><![CDATA[<p>Hermes JMS是一个开源免费的跨平台的JMS消息监听工具。它可以很方便和各种JMS框架集成和交互，可以用来监听、发送、接收、修改、存储消息等。这篇文章将讲解HermesJMS如何集成ActiveMQ并与其交互。</p>

<!-- more -->


<p>ActiveMQ在通过命令行运行时会自动启动一个Web终端，默认地址是<a href="http://localhost:8161/admin">http://localhost:8161/admin</a>，默认用户名/密码为admin/admin。通过这个web终端可以监控和操作ActiveMQ。但是这个Web终端有两个缺陷，第一是功能较弱，有些需求不能满足；第二是只有通过命令行启动ActiveMQ才会启动这个Web终端，如果是使用内置的broker，则无法使用该Web终端。而HermesJMS恰好弥补了这两个缺陷。</p>

<p>要想使用HermesJMS，首先要下载它。HermesJMS的官方网站是<a href="http://www.hermesjms.com/confluence/display/HJMS/Home">http://www.hermesjms.com/confluence/display/HJMS/Home</a>。其源码放置在sourceforge上。目前最新版本是1.14，已经两年多没推出新版本了。下载地址:<a href="http://sourceforge.net/projects/hermesjms/files/hermesjms/1.14/">http://sourceforge.net/projects/hermesjms/files/hermesjms/1.14/</a>。MAC系统的要下载dmg文件，其余系统可下载jar文件。</p>

<p>下载完成以后，要配置ActiveMQ到provider去。打开Hermes，点击<code>create new session</code>按钮，然后在界面下方选中Providers tab，添加对ActiveMQ的配置。我们以ActiveMQ5.8.0版本为例。首先创建一个名为ActiveMQ5.8.0的group，然后向其添加两个jar包:activemq-all-5.8.0.jar及geronimo-j2ee-management_1.1_spec_1.0.1.jar。这两个jar包都可以在ActiveMQ安装目录下找到。</p>

<p><img src="/images/setupProvider.png" width="800"></p>

<p>然后就可以创建一个ActiveMQ的Session了。点击Sessions tab，输入以下配置信息。</p>

<p><img src="/images/setupSession.png" width="800"></p>

<p>设置Plugin为ActiveMQ是为了能够自动检测当前Provider中的Queue和Topic信息。</p>

<p>然后启动一个ActiveMQ broker。</p>

<p>```bash</p>

<p>$:/usr/local/Cellar/activemq/5.8.0/libexec$ activemq console xbean:./conf/activemq-demo.xml</p>

<p>```</p>

<p>这样就可以通过hermesJMS和其进行交互了。双击左侧菜单树中的msgQueue节点，可以查看该Queue中的信息。右键点击该节点选择<code>send message</code>向Queue中发送信息。</p>

<p><img src="/images/sendMessage.png" width="800"></p>

<p>然后刷新Queue就可以看到消息已经在Queue里了。</p>

<p><img src="/images/monitorQueue.png" width="800"></p>

<p>我们也可以打开ActiveMQ的Web终端向msgQueue中发送消息。地址:<a href="http://localhost:8161/admin/queues.jsp">http://localhost:8161/admin/queues.jsp</a></p>

<p><img src="/images/webconsole.png" width="800"></p>

<p>然后在HermesJMS中刷新即可看到新的消息。</p>

<p><img src="/images/msgFromWebConsole.png" width="800"></p>

<p>Hermes JMS还支持将消息存储到一个JDBC数据库中，具体可以查阅官方文档。</p>

<p>在使用Hermes JMS的过程中可以说到处是坑，软件弹出异常的次数不少于20次。可以说这个软件在健壮性、和兼容性方面还需要增强。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveMQ第三弹:在Spring中使用内置的Message Broker]]></title>
    <link href="http://www.huangbowen.net/blog/2014/02/22/using-embeded-broker-in-spring/"/>
    <updated>2014-02-22T19:16:00+10:00</updated>
    <id>http://www.huangbowen.net/blog/2014/02/22/using-embeded-broker-in-spring</id>
    <content type="html"><![CDATA[<p>在上个例子中我们演示了如何使用Spring JMS来向ActiveMQ发送消息和接收消息。但是这个例子需要先从控制台使用ActiveMQ提供的命令行功能启动一个Message Broker,然后才能运行示例。这个Message Broker就相当于一个server，无论是发送方还是接收方都可以连接到这个Server进行消息的处理。在某些情况下，让Message Broker和consumer启动在同一个JVM里面，通信效率肯定会高不少。</p>

<!-- more -->


<p>ActiveMQ提供了很多方式来创建内置的broker。这篇文章主要介绍使用Spring及XBean来创建一个内置的broker。</p>

<p>首先需要在项目中引入xbean-spring依赖项。</p>

<p>```xml pom.xml</p>

<pre><code>  &lt;dependency&gt;
      &lt;groupId&gt;org.apache.xbean&lt;/groupId&gt;
      &lt;artifactId&gt;xbean-spring&lt;/artifactId&gt;
      &lt;version&gt;3.16&lt;/version&gt;
  &lt;/dependency&gt; 
</code></pre>

<p>```</p>

<p>然后在Spring配置文件中加入以下代码:</p>

<p>```xml</p>

<pre><code>&lt;amq:broker id="activeMQBroker"&gt;
    &lt;amq:transportConnectors&gt;
        &lt;amq:transportConnector uri="${jms.broker.url}" /&gt;
    &lt;/amq:transportConnectors&gt;
&lt;/amq:broker&gt; 
</code></pre>

<p>```</p>

<p>注意在Spring配置文件中还要加入Namespace的定义。</p>

<p>```xml</p>

<p>&lt;beans xmlns="http://www.springframework.org/schema/beans"</p>

<pre><code>   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:amq="http://activemq.apache.org/schema/core"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
   http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core-5.8.0.xsd"&gt; 
</code></pre>

<p>...
...
...</p>

<p></beans></p>

<p>```</p>

<p>完整的Spring配置如下。</p>

<p>```xml embedBroker.xml</p>

<p>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;beans xmlns="http://www.springframework.org/schema/beans"</p>

<pre><code>   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:amq="http://activemq.apache.org/schema/core"
   xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
   http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core-5.8.0.xsd"&gt;

&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;property name="location"&gt;
        &lt;value&gt;application.properties&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;!-- Activemq connection factory --&gt;
&lt;bean id="amqConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;
    &lt;!--&lt;property name="brokerURL" value="${jms.broker.url}"/&gt;--&gt;
    &lt;constructor-arg index="0" value="${jms.broker.url}"/&gt;
    &lt;property name="useAsyncSend" value="true"/&gt;
&lt;/bean&gt;

&lt;amq:broker id="activeMQBroker"&gt;
    &lt;amq:transportConnectors&gt;
        &lt;amq:transportConnector uri="${jms.broker.url}" /&gt;
    &lt;/amq:transportConnectors&gt;
&lt;/amq:broker&gt;

&lt;!-- ConnectionFactory Definition --&gt;
&lt;bean id="connectionFactory" class="org.springframework.jms.connection.CachingConnectionFactory"&gt;
    &lt;constructor-arg ref="amqConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;!--  Default Destination Queue Definition--&gt;
&lt;bean id="defaultDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt;
    &lt;constructor-arg index="0" value="${jms.queue.name}"/&gt;
&lt;/bean&gt;

&lt;!-- JmsTemplate Definition --&gt;
&lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="defaultDestination" ref="defaultDestination"/&gt;
&lt;/bean&gt;

&lt;!-- Message Sender Definition --&gt;
&lt;bean id="messageSender" class="huangbowen.net.jms.MessageSender"&gt;
    &lt;constructor-arg index="0" ref="jmsTemplate"/&gt;
&lt;/bean&gt;

&lt;!-- Message Receiver Definition --&gt;
&lt;bean id="messageReceiver" class="huangbowen.net.jms.MessageReceiver"&gt;
&lt;/bean&gt;
&lt;bean class="org.springframework.jms.listener.SimpleMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destinationName" value="${jms.queue.name}"/&gt;
    &lt;property name="messageListener" ref="messageReceiver"/&gt;
&lt;/bean&gt;
</code></pre>

<p></beans></p>

<p>```</p>

<p>在<a href="https://github.com/huangbowen521/SpringJMSSample">示例项目</a>中我新加了一个Main方法来进行测试。可以运行EmbedBrokerApp中的Main方法来进行测试。</p>

<p><img src="/images/messageTest.png"></p>

<p>如果客户端和broker在相同的JVM进程中，客户端连接时可以使用broker url为“vm://localhost:61616”,进程外连接则需要使用”tcp://localhost:61616"。如果有多个broker的话可以给每个broker起个名字。</p>

<p>```xml</p>

<pre><code>&lt;amq:broker brokerName="broker1"&gt;
    &lt;amq:transportConnectors&gt;
        &lt;amq:transportConnector uri="tcp://localhost:61616" /&gt;
    &lt;/amq:transportConnectors&gt;
&lt;/amq:broker&gt;

&lt;amq:broker brokerName="broker2"&gt;
    &lt;amq:transportConnectors&gt;
        &lt;amq:transportConnector uri="tcp://localhost:61617" /&gt;
    &lt;/amq:transportConnectors&gt;
&lt;/amq:broker&gt; 
</code></pre>

<p>```</p>

<p>客户端连接时候可以直接使用broker名称连接，比如使用”vm://broker1”来使用第一个broker。</p>

<p>本章中的完整源码可从完整代码可从<a href="https://github.com/huangbowen521/SpringJMSSample">https://github.com/huangbowen521/SpringJMSSample</a>下载。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveMQ第二弹:使用Spring JMS与ActiveMQ通讯]]></title>
    <link href="http://www.huangbowen.net/blog/2014/02/20/spring-jms-and-activemq-sample/"/>
    <updated>2014-02-20T23:18:00+10:00</updated>
    <id>http://www.huangbowen.net/blog/2014/02/20/spring-jms-and-activemq-sample</id>
    <content type="html"><![CDATA[<p>本文章的完整代码可从我的github中下载：<a href="https://github.com/huangbowen521/SpringJMSSample.git">https://github.com/huangbowen521/SpringJMSSample.git</a></p>

<p>上一篇文章中介绍了如何安装和运行ActiveMQ。这一章主要讲述如何使用Spring JMS向ActiveMQ的Message Queue中发消息和读消息。</p>

<!-- more -->


<p>首先需要在项目中引入依赖库。</p>

<ul>
<li><p>spring-core: 用于启动Spring容器，加载bean。</p></li>
<li><p>spring-jms:使用Spring JMS提供的API。</p></li>
<li><p>activemq-all:使用ActiveMQ提供的API。</p></li>
</ul>


<p>在本示例中我使用maven来导入相应的依赖库。</p>

<p>```xml pom.xml</p>

<p>  <dependencies></p>

<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;junit&lt;/groupId&gt;
  &lt;artifactId&gt;junit&lt;/artifactId&gt;
  &lt;version&gt;4.11&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
      &lt;artifactId&gt;activemq-all&lt;/artifactId&gt;
      &lt;version&gt;5.9.0&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;
      &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
      &lt;version&gt;4.0.2.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;
</code></pre>

<p>  </dependencies></p>

<p>```</p>

<p>接下来配置与ActiveMQ的连接，以及一个自定义的MessageSender。</p>

<p>```xml springJMSConfiguration.xml</p>

<p>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;beans xmlns="http://www.springframework.org/schema/beans"</p>

<pre><code>   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://www.springframework.org/schema/beans
</code></pre>

<p> http://www.springframework.org/schema/beans/spring-beans.xsd"></p>

<pre><code>&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;property name="location"&gt;
        &lt;value&gt;application.properties&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;!-- Activemq connection factory --&gt;
&lt;bean id="amqConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;
    &lt;constructor-arg index="0" value="${jms.broker.url}"/&gt;
&lt;/bean&gt;

&lt;!-- ConnectionFactory Definition --&gt;
&lt;bean id="connectionFactory" class="org.springframework.jms.connection.CachingConnectionFactory"&gt;
    &lt;constructor-arg ref="amqConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;!--  Default Destination Queue Definition--&gt;
&lt;bean id="defaultDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt;
    &lt;constructor-arg index="0" value="${jms.queue.name}"/&gt;
&lt;/bean&gt;

&lt;!-- JmsTemplate Definition --&gt;
&lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="defaultDestination" ref="defaultDestination"/&gt;
&lt;/bean&gt;

&lt;!-- Message Sender Definition --&gt;
&lt;bean id="messageSender" class="huangbowen.net.jms.MessageSender"&gt;
    &lt;constructor-arg index="0" ref="jmsTemplate"/&gt;
&lt;/bean&gt;
</code></pre>

<p></beans></p>

<p>```</p>

<p>在此配置文件中，我们配置了一个ActiveMQ的connection factory,使用的是ActiveMQ提供的ActiveMQConnectionFactory类。然后又配置了一个Spring JMS提供的CachingConnectionFactory。我们定义了一个ActiveMQQueue作为消息的接收Queue。并创建了一个JmsTemplate，使用了之前创建的ConnectionFactory和Message Queue作为参数。最后自定义了一个MessageSender，使用该JmsTemplate进行消息发送。</p>

<p>以下MessageSender的实现。</p>

<p>```java MessageSender.java</p>

<p>package huangbowen.net.jms;</p>

<p>import org.springframework.jms.core.JmsTemplate;</p>

<p>public class MessageSender {</p>

<pre><code>private final JmsTemplate jmsTemplate;

public MessageSender(final JmsTemplate jmsTemplate) {
    this.jmsTemplate = jmsTemplate;
}

public void send(final String text) {
    jmsTemplate.convertAndSend(text);
}
</code></pre>

<p>}</p>

<p>```
这个MessageSender很简单，就是通过jmsTemplate发送一个字符串信息。</p>

<p>我们还需要配置一个Listener来监听和处理当前的Message Queue。</p>

<p>```xml springJMSReceiver.xml</p>

<p>&lt;?xml version="1.0" encoding="UTF-8"?>
&lt;beans xmlns="http://www.springframework.org/schema/beans"</p>

<pre><code>   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://www.springframework.org/schema/beans
</code></pre>

<p> http://www.springframework.org/schema/beans/spring-beans.xsd"></p>

<pre><code>&lt;!-- Message Receiver Definition --&gt;
&lt;bean id="messageReceiver" class="huangbowen.net.jms.MessageReceiver"&gt;
&lt;/bean&gt;
&lt;bean class="org.springframework.jms.listener.SimpleMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destinationName" value="${jms.queue.name}"/&gt;
    &lt;property name="messageListener" ref="messageReceiver"/&gt;
&lt;/bean&gt;
</code></pre>

<p></beans></p>

<p>```</p>

<p>在上述xml文件中,我们自定义了一个MessageListener，并且使用Spring提供的SimpleMessageListenerContainer作为Container。</p>

<p>以下是MessageLinser的具体实现。</p>

<p>```java MessageReceiver.java</p>

<p>package huangbowen.net.jms;</p>

<p>import javax.jms.*;</p>

<p>public class MessageReceiver implements MessageListener {</p>

<pre><code>public void onMessage(Message message) {
    if(message instanceof TextMessage) {
        TextMessage textMessage = (TextMessage) message;
        try {
            String text = textMessage.getText();
            System.out.println(String.format("Received: %s",text));
        } catch (JMSException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>

<p>}</p>

<p>```</p>

<p>这个MessageListener也相当的简单，就是从Queue中读取出消息以后输出到当前控制台中。</p>

<p>另外有关ActiveMQ的url和所使用的Message Queue的配置在application.properties文件中。</p>

<p>```xml application.properties</p>

<p>jms.broker.url=tcp://localhost:61616
jms.queue.name=bar</p>

<p>```</p>

<p>好了，配置大功告成。如何演示那？我创建了两个Main方法，一个用于发送消息到ActiveMQ的MessageQueue中，一个用于从MessageQueue中读取消息。</p>

<p>```java SenderApp</p>

<p>package huangbowen.net;</p>

<p>import huangbowen.net.jms.MessageSender;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.util.StringUtils;</p>

<p>import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;</p>

<p>public class SenderApp
{</p>

<pre><code>public static void main( String[] args ) throws IOException {
    MessageSender sender = getMessageSender();
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String text = br.readLine();

    while (!StringUtils.isEmpty(text)) {
        System.out.println(String.format("send message: %s", text));
        sender.send(text);
        text = br.readLine();
    }
}

public static MessageSender getMessageSender() {
    ApplicationContext context = new ClassPathXmlApplicationContext("springJMSConfiguration.xml");
   return (MessageSender) context.getBean("messageSender");
}
</code></pre>

<p>}</p>

<p>```</p>

<p>```java ReceiverApp.java</p>

<p>package huangbowen.net;</p>

<p>import org.springframework.context.support.ClassPathXmlApplicationContext;</p>

<p>public class ReceiverApp {</p>

<pre><code>public static void main( String[] args )
{
    new ClassPathXmlApplicationContext("springJMSConfiguration.xml", "springJMSReceiver.xml");
}
</code></pre>

<p>}</p>

<p>```</p>

<p>OK，如果运行的话要先将ActiveMQ服务启动起来（更多启动方式参见我上篇文章）。</p>

<p>```bash</p>

<p>$:/usr/local/Cellar/activemq/5.8.0/libexec$ activemq start xbean:./conf/activemq-demo.xml</p>

<p>```</p>

<p>然后运行SenderApp中的Main方法，就可以在控制台中输入消息发送到ActiveMQ的Message Queue中了。运行ReceiverApp中的Main方法，则会从Queue中将消息读出来，打印到控制台。</p>

<p>这就是使用Spring JMS与ActiveMQ交互的一个简单例子了。完整代码可从https://github.com/huangbowen521/SpringJMSSample下载。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveMQ第一弹:安装与运行]]></title>
    <link href="http://www.huangbowen.net/blog/2014/02/20/install-and-run-activemq/"/>
    <updated>2014-02-20T00:12:00+10:00</updated>
    <id>http://www.huangbowen.net/blog/2014/02/20/install-and-run-activemq</id>
    <content type="html"><![CDATA[<p>ActiveMQ使用java写的，所以天然跨平台，windows，各种类Unix系统都可运行，只需要下载对应的分发包即可。当前AciveMQ的最新版本是5.9.0。我目前在自己机子上安装的版本是5.8.0。</p>

<!-- more -->


<p>安装ActivceMQ需要先设置好系统环境。</p>

<ol>
<li><p>空间剩余磁盘大于60M。（这个肯定没问题）</p></li>
<li><p>需要预装JDK，版本为1.6.x及其以上。（ActiveMQ就是用java写的，肯定要装java环境的嘛）</p></li>
</ol>


<p>接下来就可以安装ActiveMQ了。</p>

<p>一种是直接下载分发包，地址是<a href="http://activemq.apache.org/">http://activemq.apache.org/</a>。找到想要安装的版本后解压缩即可。</p>

<p>另一种是通过源代码安装，地址是<a href="http://activemq.apache.org/download.html">http://activemq.apache.org/download.html</a>。该源代码是使用maven作为构建工具的，所以需要先安装maven，如何安装可参见<a href="http://maven.apache.org/">maven官网</a>（MAC用户如果安装了homebrew的话，直接运行<code>brew install maven</code>即可）。    然后使用<code>mvn clean install -Dmaven.test.skip=true</code>来构建源代码。如果构建成功的话在target目录下可以看到生成的activemq-x.x-SNAPSHOT.zip文件，解压缩以后就可以使用了。</p>

<p>当然MAC用户的话安装就简单了，直接使用<code>brew install activemq</code>就行（不知道homebrew为何物的参见我写的文章：
<a href="http://www.huangbowen.net/blog/2013/07/01/homebrew-in-mac/">Homebrew- MAC上的包管理利器</a>）。ActiveMQ会被默认安装到/usr/local/Cellar/activemq。</p>

<p>```bash</p>

<p>$:/usr/local/Cellar/activemq$ ls
5.7.0 5.8.0
$:/usr/local/Cellar/activemq$ cd 5.8.0
$:/usr/local/Cellar/activemq/5.8.0$ ls
INSTALL_RECEIPT.json NOTICE               bin
LICENSE              README.txt           libexec</p>

<p>```</p>

<p>HomeBrew会自动将activemq加入到系统路径中。</p>

<p>下表列出了与ActiveMQ有关的一些重要的环境变量。</p>

<ul>
<li><p>ACTIVEMQ_HOME: /usr/local/Cellar/activemq/5.8.0/libexec</p></li>
<li><p>ACTIVEMQ_BASE: /usr/local/Cellar/activemq/5.8.0/libexec</p></li>
<li><p>ACTIVEMQ_CONF: /usr/local/Cellar/activemq/5.8.0/libexec/conf</p></li>
<li><p>ACTIVEMQ_DATA: /usr/local/Cellar/activemq/5.8.0/libexec/data</p></li>
</ul>


<p><strong>注意一下所有命令有时基于ActiveMQ 5.8.0版本，不同版本命令稍有不同。</strong></p>

<p>先运行<code>activemq setup ~/.activemqrc</code>来指定activemq的环境配置文件。在这个文件中可以自定义activemq使用的JDK路径，jvm参数等信息。</p>

<p>```bash</p>

<p>$:/usr/local/Cellar/activemq/5.8.0$ activemq setup ~/.activemqrc
INFO: Loading '/Users/twer/.activemqrc'
INFO: Creating configuration file: /Users/twer/.activemqrc
INFO: It's recommend to limit access to '/Users/twer/.activemqrc' to the priviledged user
INFO: (recommended: chown 'twer':nogroup '/Users/twer/.activemqrc'; chmod 600 '/Users/twer/.activemqrc’)</p>

<p>```</p>

<p>运行<code>activemq</code>可以显示activemq相应的配置信息及可用的命令。（注意低版本中此命令是启动ActiveMQ）</p>

<p>运行<code>activemq start</code>可以在一个独立进程中启动activemq。</p>

<p>```bash</p>

<p>$:/usr/local/Cellar/activemq/5.8.0$ activemq start
INFO: Loading '/Users/twer/.activemqrc'
INFO: Using java '/System/Library/Frameworks/JavaVM.framework/Home/bin/java'
INFO: Starting - inspect logfiles specified in logging.properties and log4j.properties to get details
INFO: pidfile created : '/usr/local/Cellar/activemq/5.8.0/libexec/data/activemq-bowen-huang.local.pid' (pid '50873')</p>

<p>```</p>

<p>可以看到进程id是50873.</p>

<p>终止ActiveMQ的运行有两种方式。一种是使用<code>activemq stop</code>。</p>

<p>```bash</p>

<p>$:/usr/local/Cellar/activemq/5.8.0$ activemq stop
INFO: Loading '/Users/twer/.activemqrc'
INFO: Using java '/System/Library/Frameworks/JavaVM.framework/Home/bin/java'
INFO: Waiting at least 30 seconds for regular process termination of pid '50873' :
Java Runtime: Apple Inc. 1.6.0_65 /System/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home
  Heap sizes: current=1035520k  free=1033420k  max=1035520k</p>

<pre><code>JVM args: -Xms1G -Xmx1G -Djava.util.logging.config.file=logging.properties -Dactivemq.classpath=/usr/local/Cellar/activemq/5.8.0/libexec/conf; -Dactivemq.home=/usr/local/Cellar/activemq/5.8.0/libexec -Dactivemq.base=/usr/local/Cellar/activemq/5.8.0/libexec -Dactivemq.conf=/usr/local/Cellar/activemq/5.8.0/libexec/conf -Dactivemq.data=/usr/local/Cellar/activemq/5.8.0/libexec/data
</code></pre>

<p>Extensions classpath:
  [/usr/local/Cellar/activemq/5.8.0/libexec/lib,/usr/local/Cellar/activemq/5.8.0/libexec/lib/camel,/usr/local/Cellar/activemq/5.8.0/libexec/lib/optional,/usr/local/Cellar/activemq/5.8.0/libexec/lib/web,/usr/local/Cellar/activemq/5.8.0/libexec/lib/extra]
ACTIVEMQ_HOME: /usr/local/Cellar/activemq/5.8.0/libexec
ACTIVEMQ_BASE: /usr/local/Cellar/activemq/5.8.0/libexec
ACTIVEMQ_CONF: /usr/local/Cellar/activemq/5.8.0/libexec/conf
ACTIVEMQ_DATA: /usr/local/Cellar/activemq/5.8.0/libexec/data
Connecting to pid: 50873
.Stopping broker: localhost
… FINISHED</p>

<p>```</p>

<p>另一种则是暴力的杀死进程,即<code>kill 50873</code>。</p>

<p>运行<code>activemq console</code>则会在当前console中启动activemq。这种好处是不用多开一个进程，而且可以直接从console中看到log。关闭activemq也很简单，直接按<code>ctrl</code>+<code>C</code>终止终端运行。</p>

<p>ActiveMQ的默认端口是61616，可以检测这端口来判断ActiveMQ是否启动成功。</p>

<p>```bash</p>

<p>$:/usr/local/Cellar/activemq/5.8.0$ netstat -an|grep 61616
tcp46      0      0  <em>.61616                </em>.*                    LISTEN</p>

<p>```</p>

<p>也可以访问web终端<a href="http://localhost:8161/admin">http://localhost:8161/admin</a>来查看和管理ActiveMQ。（默认用户名密码是admin/admin，你也可以修改配置，其在ActiveMQ安装目录下的libexec/conf/jetty-real.properties文件中）。</p>

<p>ActiveMQ支持xml文件格式对其进行配置。其实我们运行<code>activemq start</code>时，ActiveMQ就是默认使用了其安装目录下的libexec/conf/activemq.xml文件。</p>

<p>```bash</p>

<p>$:/usr/local/Cellar/activemq/5.8.0/libexec/conf$ ls
activemq-command.xml                 broker.ks
activemq-demo.xml                    broker.ts
activemq-dynamic-network-broker1.xml camel.xml
activemq-dynamic-network-broker2.xml client.ks
activemq-jdbc.xml                    client.ts
activemq-scalability.xml             credentials-enc.properties
activemq-security.xml                credentials.properties
activemq-specjms.xml                 jetty-demo.xml
activemq-static-network-broker1.xml  jetty-realm.properties
activemq-static-network-broker2.xml  jetty.xml
activemq-stomp.xml                   jmx.access
activemq-throughput.xml              jmx.password
activemq.xml                         log4j.properties
broker-localhost.cert                logging.properties</p>

<p>```</p>

<p>我们当然可以使用自定义的配置文件，比如我们改用activemq-demo.xml。</p>

<p>```bash</p>

<p>$:/usr/local/Cellar/activemq/5.8.0/libexec$ activemq start xbean:./conf/activemq-demo.xml
INFO: Loading '/Users/twer/.activemqrc'
INFO: Using java '/System/Library/Frameworks/JavaVM.framework/Home/bin/java'
INFO: Starting - inspect logfiles specified in logging.properties and log4j.properties to get details
INFO: pidfile created : '/usr/local/Cellar/activemq/5.8.0/libexec/data/activemq-bowen-huang.local.pid' (pid '51375’)</p>

<p>```</p>

<p>ActiveMQ在5.8.0版本及之后在安装包中包含了一些demo来演示对ActiveMQ的使用。使用方式很简单，首先采用activemq-demo.xml配置文件来启动ActiveMQ，然后访问<a href="http://localhost:8161/demo/">http://localhost:8161/demo/</a>尽情探索把。</p>

<p>这些demo的源码都在ActiveMQ安装目录下的libexec目录中，里面有个<code>user-guide.html</code>，可以用浏览器直接打开，它详细描述了该如何使用这些demo。</p>
]]></content>
  </entry>
  
</feed>
