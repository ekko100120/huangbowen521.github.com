<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Spring | 黄博文的地盘]]></title>
  <link href="http://www.huangbowen.net/blog/categories/spring/atom.xml" rel="self"/>
  <link href="http://www.huangbowen.net/"/>
  <updated>2017-09-15T18:37:41+08:00</updated>
  <id>http://www.huangbowen.net/</id>
  <author>
    <name><![CDATA[黄博文]]></name>
    <email><![CDATA[huangbowen521@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring Batch在大型企业中的最佳实践]]></title>
    <link href="http://www.huangbowen.net/blog/2016/11/30/spring-batch-best-practices/"/>
    <updated>2016-11-30T23:36:45+08:00</updated>
    <id>http://www.huangbowen.net/blog/2016/11/30/spring-batch-best-practices</id>
    <content type="html"><![CDATA[<p>在大型企业中，由于业务复杂、数据量大、数据格式不同、数据交互格式繁杂，并非所有的操作都能通过交互界面进行处理。而有一些操作需要定期读取大批量的数据，然后进行一系列的后续处理。这样的过程就是“批处理”。</p>

<!-- more -->


<p>批处理应用通常有以下特点：</p>

<ul>
<li>数据量大，从数万到数百万甚至上亿不等；</li>
<li>整个过程全部自动化，并预留一定接口进行自定义配置；</li>
<li>这样的应用通常是周期性运行，比如按日、周、月运行；</li>
<li>对数据处理的准确性要求高，并且需要容错机制、回滚机制、完善的日志监控等。</li>
</ul>


<h2>什么是Spring batch</h2>

<p>Spring batch是一个轻量级的全面的批处理框架，它专为大型企业而设计，帮助开发健壮的批处理应用。Spring batch为处理大批量数据提供了很多必要的可重用的功能，比如日志追踪、事务管理、job执行统计、重启job和资源管理等。同时它也提供了优化和分片技术用于实现高性能的批处理任务。</p>

<p>它的核心功能包括：</p>

<ul>
<li>事务管理</li>
<li>基于块的处理过程</li>
<li>声明式的输入/输出操作</li>
<li>启动、终止、重启任务</li>
<li>重试/跳过任务</li>
<li>基于Web的管理员接口</li>
</ul>


<hr />

<p>笔者所在的部门属于国外某大型金融公司的CRM部门，在日常工作中我们经常需要开发一些批处理应用，对Spring Batch有着丰富的使用经验。近段时间笔者特意总结了这些经验。</p>

<h2>使用Spring Batch 3.0以及Spring Boot</h2>

<p>在使用Spring Batch时推荐使用最新的Spring Batch 3.0版本。相比Spring Batch2.2，它做了以下方面的提升：</p>

<ul>
<li>支持JSR-352标准</li>
<li>支持Spring4以及Java8</li>
<li>增强了Spring Batch Integration的功能</li>
<li>支持JobScope</li>
<li>支持SQLite</li>
</ul>


<p>支持Spring4和Java8是一个重大的提升。这样就可以使用Spring4引入的Spring boot组件，从而开发效率方面有了一个质的飞跃。引入Spring-batch框架只需要在build.gradle中加入一行代码即可：</p>

<pre><code>compile("org.springframework.boot:spring-boot-starter-batch")
</code></pre>

<p>而增强Spring Batch Integration的功能后，我们就可以很方便的和Spring家族的其他组件集成，还可以以多种方式来调用job，也支持远程分区操作以及远程块处理。</p>

<p>而支持JobScope后我们可以随时为对象注入当前Job实例的上下文信息。只要我们制定Bean的scope为job scope，那么就可以随时使用jobParameters和jobExecutionContext等信息。</p>

<pre><code>
@Component
@JobScope
public class CustomClass {

    @Value("#{jobParameters[jobDate]}")
    private String jobDate;

    @Value("#{jobExecutionContext['input.name']}.")
    private String fileName;
}
</code></pre>

<h2>使用Java Config而不是xml的配置方式</h2>

<p>之前我们在配置job和step的时候都习惯用xml的配置方式，但是随着时间的推移发现问题颇多。</p>

<ul>
<li>xml文件数急剧膨胀，配置块长且复杂，可读性很差；</li>
<li>xml文件缺少语法检查，有些低级错误只有在运行集成测试的时候才能发现；</li>
<li>在xml文件中进行代码跳转时IDE的支持力度不够；</li>
</ul>


<p>我们渐渐发现使用纯Java类的配置方式更灵活，它是类型安全的，而且IDE的支持更好。在构建job或step时采用的流式语法相比xml更加简洁易懂。</p>

<pre><code>
        @Bean
        public Step step(){
                return stepBuilders.get("step")
                                .&lt;Partner,Partner&gt;chunk(1)
                                .reader(reader())
                                .processor(processor())
                                .writer(writer())
                                .listener(logProcessListener())
                                .faultTolerant()
                                .skipLimit(10)
                                .skip(UnknownGenderException.class)
                                .listener(logSkipListener())
                                .build();
        }
</code></pre>

<p>在这个例子中可以很清楚的看到该step的配置，比如reader/processor/writer组件，以及配置了哪些listener等。</p>

<h2>本地集成测试中使用内存数据库</h2>

<p>Spring batch在运行时需要数据库支持，因为它需要在数据库中建立一套schema来存储job和step运行的统计信息。而在本地集成测试中我们可以借助Spring batch提供的内存Repository来存储Spring batch的任务执行信息，这样即避免了在本地配置一个数据库，又可以加快job的执行。先为Job的配置类添加扩展类：DefaultBatchConfigurer。</p>

<pre><code>public class CustomJobConfiguration extends DefaultBatchConfigurer {

    ...
}
</code></pre>

<p>我们在build.gradle中加入对hsqldb的依赖：</p>

<pre><code>runtime(‘org.hsqldb:hsqldb:2.3.2’)
</code></pre>

<p>然后在测试类中添加对DataSource的配置。</p>

<pre><code>@EnableAutoConfiguration
@EnableBatchProcessing
@DataJpaTest
@Import({DataSourceAutoConfiguration.class, BatchAutoConfiguration.class})
public class TestConfiguration {

}
</code></pre>

<p>并且在applicaton.properties配置中添加初始化Database的配置：</p>

<pre><code>spring.batch.initializer.enable=true
</code></pre>

<h2>合理的使用Chunk机制</h2>

<p>Spring batch在配置Step时采用的是基于Chunk的机制。即每次读取一条数据，再处理一条数据，累积到一定数量后再一次性交给writer进行写入操作。这样可以最大化的优化写入效率，整个事务也是基于Chunk来进行。</p>

<p>当我们在需要将数据写入到文件、数据库中之类的操作时可以适当设置Chunk的值以满足写入效率最大化。但有些场景下我们的写入操作其实是调用一个web service或者将消息发送到某个消息队列中，那么这些场景下我们就需要设置Chunk的值为1，这样既可以及时的处理写入，也不会由于整个Chunk中发生异常后，在重试时出现重复调用服务或者重复发送消息的情况。</p>

<h2>使用Listener来监视job执行情况并及时做相应的处理</h2>

<p>Spring batch提供了大量的Listener来对job的各个执行环节进行全面的监控。</p>

<p>在job层面Spring batch提供了JobExecutionListener接口，其支持在Job开始或结束时进行一些额外处理。在step层面Spring batch提供了StepExecutionListener，ChunkListener,ItemReadListener,ItemProcessListener,ItemWriteListener,SkipListener等接口，同时对Retry和Skip操作也提供了RetryListener及SkipListener。</p>

<p>通常我们会为每个job都实现一个JobExecutionListener，在afterJob操作中我们输出job的执行信息，包括执行时间、job参数、退出代码、执行的step以及每个step的详细信息。这样无论是开发、测试还是运维人员对整个job的执行情况了如指掌。</p>

<p>如果某个step会发生skip的操作，我们也会为其实现一个SkipListener，并在其中记录skip的数据条目，用于下一步的处理。</p>

<p>实现Listener有两种方式，一种是继承自相应的接口，比如继承JobExecutionListener接口，另一种是使用annoation（注解）的方式。经过实践我们认为使用注解的方式更好一些，因为使用接口你需要实现接口的所有方法，而使用注解则只需要对相应的方法添加annoation即可。</p>

<p>下面的这个类采用了继承接口的方式，我们看到其实我们只用到了第一个方法，第二个和第三个都没有用到。但是我们必须提供一个空的实现。</p>

<pre><code>public class CustomSkipListener implements SkipListener&lt;String, String&gt; {
    @Override
    public void onSkipInRead(Throwable t) {
        // business logic
    }

    @Override
    public void onSkipInWrite(String item, Throwable t) {
        // no need
    }

    @Override
    public void onSkipInProcess(String item, Throwable t) {
        // no need
    }
}
</code></pre>

<p>而使用annoation的方式可以简写为：</p>

<pre><code>public class CustomSkipListener {

    @OnSkipInRead
    public void onSkipInRead(Throwable t) {
        // business logic
    }
}
</code></pre>

<h2>使用Retry和Skip增强批处理工作的健壮性</h2>

<p>在处理百万级的数据过程过程中难免会出现异常。如果一旦出现异常而导致整个批处理工作终止的话那么会导致后续的数据无法被处理。Spring Batch内置了Retry（重试）和Skip（跳过）机制帮助我们轻松处理各种异常。我们需要将异常分为三种类型。第一种是需要进行Retry的异常，它们的特点是该异常可能会随着时间推移而消失，比如数据库目前有锁无法写入、web服务当前不可用、web服务满载等。所以对它们适合配置Retry机制。第二种是需要Skip的异常，比如解析文件的某条数据出现异常等，因为对这些异常即使执行Retry每次的结果也都是相同，但又不想由于某条数据出错而停止对后续数据的处理。第三种异常是需要让整个Job立刻失败的异常，比如如果出现了OutOfMemory的异常，那么需要整个Job立刻运行。</p>

<p>一般来说需要Retry的异常也要配置Skip选项，从而保证后续的数据能够被继续处理。我们也可以配置SkipLimit选项保证当Skip的数据条目达到一定数量后及时终止整个Job。</p>

<p>有时候我们需要在每次Retry中间隔做一些操作，比如延长Retry时间，恢复操作现场等，Spring Batch提供了BackOffPolicy来达到目的。下面是一个配置了Retry机制、Skip机制以及BackOffPolicy的step示例。</p>

<pre><code>
@Bean
public Step step(){
    return stepBuilders.get("step")
            .&lt;Partner,Partner&gt;chunk(1)
            .reader(reader())
            .processor(processor())
            .writer(writer())
            .listener(logProcessListener())
            .faultTolerant()
            .skipLimit(10)
            .skip(UnknownGenderException.class)
            .skip(ServiceUnavailableException.class)
            .retryLimit(5)
            .retry(ServiceUnavailableException.class)
            .backOffPolicy(backoffPolicy)
            .listener(logSkipListener())
            .build();
}
</code></pre>

<h2>使用自定义的Decider来实现Job flow</h2>

<p>在Job执行过程中不一定都是顺序执行的，我们经常需要根据某个job的输出数据或执行结果来决定下一步的走向。以前我们会把一些判断放置在下游step中进行，这样可能会导致有些step实际运行了，但其实并没有做任何事情。比如一个step执行过程中会将失败的数据条目记录到一个报告中，而下一个step会判断有没有生成报告，如果生成了报告则将该报告发送给指定联系人，如果没有则不做任何事情。这种情况下可以通过Decider机制来实现Job的执行流程。在Spring batch 3.0中Decider已经从Step中独立出来，和Step处于同一级别。</p>

<pre><code>public class ReportDecider implements JobExecutionDecider {
    @Override
    public FlowExecutionStatus decide(JobExecution jobExecution, StepExecution stepExecution) {
        if (report.isExist()) {
            return new FlowExecutionStatus(“SEND");
        }

        return new FlowExecutionStatus(“SKIP");
    }
}
</code></pre>

<p>而在job配置中可以这样来使用Decider。这样整个Job的执行流程会更加清晰易懂。</p>

<pre><code>public Job job() {
    return new JobBuilder("petstore")
            .start(orderProcess())
            .next(reportDecider)
            .on("SEND").to(sendReportStep)
            .on("SKIP").end().build()
            .build()
}
</code></pre>

<h2>采用多种机制加速Job的执行</h2>

<p>批处理工作处理的数据量大，而执行窗口一般又要求比较小。所以必须要通过多种方式来加速Job的执行。一般我们有四种方式来实现：</p>

<ul>
<li>在单个step中多线程执行任务</li>
<li>并行执行不同的Step</li>
<li>并行执行同一个Step</li>
<li>远程执行Chunk任务</li>
</ul>


<p>在单个step多线程执行任务可以借助于taskExecutor来实现。这种情况适合于reader、writer是线程安全的并且是无状态的场景。我们还可以设置线程数量。</p>

<pre><code>    public Step step() {
        return stepBuilders.get("step")
                .tasklet(tasklet)
                .throttleLimit(20)
                .build();
    }
</code></pre>

<p>上述示例中的tasklet需要实现TaskExecutor，Spring Batch提供了一个简单的多线程TaskExecutor供我们使用：SimpleAsyncTaskExecutor。</p>

<p>并行执行不同的Step在Spring batch中很容易实现，以下是一个示例：</p>

<pre><code>public Job job() {
    return stepBuilders.get("parallelSteps")
            .start(step1)
            .split(asyncTaskExecutor).add(flow1, flow2)
            .next(step3)
            .build();
}
</code></pre>

<p>在这个示例中我们先执行step1，然后并行执行flow1和flow2，最后再执行step3。</p>

<p>Spring batch提供了PartitionStep来实现对同一个step在多个进程中实现并行处理。通过PartitonStep再配合PartitionHandler可以将一个step扩展到多个Slave上实现并行运行。</p>

<p>远程执行Chunk任务则是将某个Step的processer操作分割到多个进程中，多个进程通过一些中间件进行通讯（比如采用消息的方式）。这种方式适合于Processer是瓶颈而Reader和Writer不是瓶颈的场景。</p>

<h2>结语</h2>

<hr />

<p>Spring Batch对批处理场景进行了合理的抽象，封装了大量的实用功能，使用它来开发批处理应用可以达到事半功倍的效果。在使用的过程中我们仍需要坚持总结一些最佳实践，从而能够交付高质量的可维护的批处理应用，满足企业级应用的苛刻要求。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[值得使用的Spring Boot]]></title>
    <link href="http://www.huangbowen.net/blog/2015/03/18/introduction-of-spring-boot/"/>
    <updated>2015-03-18T16:42:34+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/03/18/introduction-of-spring-boot</id>
    <content type="html"><![CDATA[<p>2013年12月12日，Spring发布了4.0版本。这个本来只是作为Java平台上的控制反转容器的库，经过将近10年的发展已经成为了一个巨无霸产品。不过其依靠良好的分层设计，每个功能模块都能保持较好的独立性，是Java平台不可多得的好用的开源应用程序框架。
Spring的4.0版本可以说是一个重大的更新，其全面支持Java8，并且对Groovy语言也有良好的支持。另外引入了非常多的新项目，比如Spring boot，Spring Cloud，Spring WebSocket等。</p>

<!-- more -->


<p>Spring由于其繁琐的配置，一度被人成为“配置地狱”，各种XML、Annotation配置，让人眼花缭乱，而且如果出错了也很难找出原因。Spring Boot项目就是为了解决配置繁琐的问题，最大化的实现convention over configuration(约定大于配置)。熟悉Ruby On Rails（ROR框架的程序员都知道，借助于ROR的脚手架工具只需简单的几步即可建立起一个Web应用程序。而Spring Boot就相当于Java平台上的ROR。</p>

<p>Spring Boot的特性有以下几条：</p>

<ul>
<li><p>创建独立Spring应用程序</p></li>
<li><p>嵌入式Tomcat，Jetty容器，无需部署WAR包</p></li>
<li><p>简化Maven及Gradle配置</p></li>
<li><p>尽可能的自动化配置Spring</p></li>
<li><p>直接植入产品环境下的实用功能，比如度量指标、健康检查及扩展配置等</p></li>
<li><p>无需代码生成及XML配置</p></li>
</ul>


<p>目前Spring Boot的版本为1.2.3,需要Java7及Spring Framework4.1.5以上的支持。如果想在Java6下使用它，需要一些额外的设置。</p>

<p>如果你想创建一个基于Spring的Web应用，只是简单的在页面中输出一个’Hello World’，按照之前的老方式，你需要创建以下文件：</p>

<ul>
<li><p>web.xml : 配置使用Spring servlet，以及web其它配置；</p></li>
<li><p>spring-servlet.xml:配置Spring servlet的配置；</p></li>
<li><p>HelloController.java: controller。</p></li>
</ul>


<p>如果你想运行它的话，需要将生成的WAR包部署到相应的Tomcat或者Jetty容器中才行，这也需要相应的配置。</p>

<p>如果使用Spring Boot的话，我们只需要创建HelloController.java。</p>

<pre><code class="java HelloController.java">
package hello;

import org.springframework.boot.*;
import org.springframework.boot.autoconfigure.*;
import org.springframework.stereotype.*;
import org.springframework.web.bind.annotation.*;

@Controller
@EnableAutoConfiguration
public class HelloController {

    @RequestMapping("/")
    @ResponseBody
    String home() {
        return "Hello World!";
    }

    public static void main(String[] args) throws Exception {
        SpringApplication.run(HelloController.class, args);
    }
}
</code></pre>

<p>然后借助于Spring Boot为Maven和Gradle提供的插件来生成Jar包以后直接运行java -jar即可，简单易用。</p>

<p>上面提过Spring Boot对Maven及Gradle等构建工具支持力度非常大。其内置一个’Starter POM’，对项目构建进行了高度封装，最大化简化项目构建的配置。另外对Maven和Gradle都有相应的插件，打包、运行无需编写额外的脚本。</p>

<p>Spring Boot不止对web应用程序做了简化，还提供一系列的依赖包来把其它一些工作做成开箱即用。下面列出了几个经典的Spring Boot依赖库。</p>

<ul>
<li><p>spring-boot-starter-web:支持全栈web开发，里面包括了Tomcat和Spring-webmvc。</p></li>
<li><p>spring-boot-starter-mail:提供对javax.mail的支持.</p></li>
<li><p>spring-boot-starter-ws: 提供对Spring Web Services的支持</p></li>
<li><p>spring-boot-starter-test:提供对常用测试框架的支持，包括JUnit，Hamcrest以及Mockito等。</p></li>
<li><p>spring-boot-starter-actuator:支持产品环境下的一些功能，比如指标度量及监控等。</p></li>
<li><p>spring-boot-starter-jetty:支持jetty容器。</p></li>
<li>spring-boot-starter-log4j:引入默认的log框架（logback）</li>
</ul>


<p>Spring Boot提供的starter比这个要多，详情请参阅文档：<a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#using-boot-starter-poms">Starter POMs</a>章节。</p>

<p>如果你不喜欢Maven或Gradle，Spring提供了CLI（Command Line Interface）来开发运行Spring应用程序。你可以使用它来运行Groovy脚本，甚至编写自定义命令。安装Spring CLI有多种方法，具体请看：<a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started-installing-the-cli">安装Spring Boot Cli</a>章节。</p>

<p>安装完毕以后可以运行 <code>srping version</code>来查看当前版本。</p>

<p>你可以使用Groovy编写一个Controller。</p>

<pre><code class="groovy hello.groovy">
@RestController
class WebApplication {

    @RequestMapping("/")
    String home() {
        "Hello World!"
    }

}
</code></pre>

<p>然后使用<code>spring run hello.groovy</code>来直接运行它。访问localhost:8080即可看到打印的信息。</p>

<p>Spring Boot提供的功能还有很多，比如对MVC的支持、外部Properties的注入，日志框架的支持等。这里就不详述了。感兴趣的可以查看其<a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/">文档</a>来获取详细的信息。</p>

<p>如果你想在你的项目中使用Spring，那么最好把Spring Boot设为标配，因为它真的很方面开发，不过你也需要仔细阅读它的文档，避免不知不觉掉入坑中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻译-使用Spring调用SOAP web service]]></title>
    <link href="http://www.huangbowen.net/blog/2014/09/10/consuming-web-service/"/>
    <updated>2014-09-10T21:02:41+08:00</updated>
    <id>http://www.huangbowen.net/blog/2014/09/10/consuming-web-service</id>
    <content type="html"><![CDATA[<p>原文链接: <a href="http://spring.io/guides/gs/consuming-web-service/">http://spring.io/guides/gs/consuming-web-service/</a></p>

<h2>调用SOAP web service</h2>

<p>本指南将指导你使用Spring调用一个基于SOAP的web service的整个过程。</p>

<!-- more -->


<h3>指南内容</h3>

<p>你将构建一个客户端，使用SOAP用来从远端的基于WSDL的web service获取天气数据。请访问<a href="http://wiki.cdyne.com/index.php/CDYNE_Weather">http://wiki.cdyne.com/index.php/CDYNE_Weather</a>进一步获取该天气服务的信息。</p>

<p>该服务根据邮编返回天气预测。你可以使用自己的邮编。</p>

<h3>准备事项</h3>

<ul>
<li><p>大约15分钟</p></li>
<li><p>钟爱的编辑器或IDE</p></li>
<li><p>JDK1.6或更高版本</p></li>
<li><p>Gradle 1.11+ 或 Maven 3.0+</p></li>
<li><p>你也可以直接参阅该指南导入代码，或通过Spring工具集（Spring Tool Suite，简称STS)通过网页浏览代码，从而帮助你学习该章节内容。源码下载地址:<a href="https://github.com/spring-guides/gs-consuming-web-service.git">https://github.com/spring-guides/gs-consuming-web-service.git</a>。</p></li>
</ul>


<h3>如何完成该指南</h3>

<p>如同大多数的<a href="http://spring.io/guides">示例教程</a>一样，你可以从头开始并完成每个步骤，或者你也可以跳过已经熟悉的基础章节。无论怎样，最终你要得到可以工作的代码。</p>

<p>想<em>从头开始</em>，请移动到<a href="#scratch">使用Gradle构建</a>章节。</p>

<p>想<em>跳过基础部分</em>，请做以下事情：</p>

<ul>
<li><p><a href="">下载</a>并解压该向导的源代码，或者使用<a href="ttp://spring.io/understanding/Git">Git</a>复制一份： <code>git clone https://github.com/spring-guides/gs-consuming-web-service.git</code></p></li>
<li><p>切换到<code>gs-consuming-web-service/initial</code></p></li>
<li><p>跳到基于WSDL生成领域对象章节。</p></li>
</ul>


<p>当完成后，你可以使用<code>gs-consuming-web-service/complete</code>目录中的代码检查你的结果。</p>

<h3><a name="#scratch">使用Gradle构建</a></h3>

<p>首先你要设置一个基本的build脚本。当构建Spring应用程序时，你可以使用任何构建系统，但是这里只包括了使用<a href="https://maven.apache.org">Maven</a>和<a href="gradle.org">Gradle</a>的代码。如果你两者都不熟悉，请访问<a href="http://spring.io/guides/gs/gradle">使用Gradle构建Java项目</a>或<a href="http://spring.io/guides/gs/maven">使用Maven构建Java项目</a>。</p>

<h4>创建目录结构</h4>

<p>在你选择的存放项目的目录中，创建如下的子目录结构。例如，在*nix系统中使用<code>mkdir -p src/main/java/hello</code>。</p>

<pre><code class="text">
└── src
    └── main
        └── java
            └── hello
</code></pre>

<h4>创建Gradle 构建文件</h4>

<p>下面是一个<a href="https://github.com/spring-guides/gs-consuming-web-service/blob/master/initial/build.gradle">初始的Gradle build文件</a>。</p>

<pre><code class="groovy build.gradle">
configurations {
    jaxb
}

buildscript {
    repositories {
        maven { url "http://repo.spring.io/libs-release" }
        mavenLocal()
        mavenCentral()
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:1.1.6.RELEASE")
    }
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'spring-boot'

repositories {
    mavenLocal()
    mavenCentral()
    maven { url 'http://repo.spring.io/libs-release' }
}

// tag::wsdl[]
task genJaxb {
    ext.sourcesDir = "${buildDir}/generated-sources/jaxb"
    ext.classesDir = "${buildDir}/classes/jaxb"
    ext.schema = "http://wsf.cdyne.com/WeatherWS/Weather.asmx?wsdl"

    outputs.dir classesDir

    doLast() {
        project.ant {
            taskdef name: "xjc", classname: "com.sun.tools.xjc.XJCTask",
                    classpath: configurations.jaxb.asPath
            mkdir(dir: sourcesDir)
            mkdir(dir: classesDir)

            xjc(destdir: sourcesDir, schema: schema,
                    package: "hello.wsdl") {
                arg(value: "-wsdl")
                produces(dir: sourcesDir, includes: "**/*.java")
            }

            javac(destdir: classesDir, source: 1.6, target: 1.6, debug: true,
                    debugLevel: "lines,vars,source",
                    classpath: configurations.jaxb.asPath) {
                src(path: sourcesDir)
                include(name: "**/*.java")
                include(name: "*.java")
            }

            copy(todir: classesDir) {
                fileset(dir: sourcesDir, erroronmissingdir: false) {
                    exclude(name: "**/*.java")
                }
            }
        }
    }
}
// end::wsdl[]

dependencies {
    compile("org.springframework.boot:spring-boot-starter")
    compile("org.springframework.ws:spring-ws-core")
    compile(files(genJaxb.classesDir).builtBy(genJaxb))

    jaxb "com.sun.xml.bind:jaxb-xjc:2.1.7"
}

jar {
    from genJaxb.classesDir
}

task wrapper(type: Wrapper) {
    gradleVersion = '1.11'
}

task afterEclipseImport {
    dependsOn genJaxb
}
</code></pre>

<p><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-tools/spring-boot-gradle-plugin">Spring Boot gradle插件</a>提供了很多便利的特性：</p>

<ul>
<li><p>将classpath中的所有jar包构建单个可运行的jar包，从而更容易执行和传播服务。</p></li>
<li><p>搜索<code>public static void main（）</code>方法并标记为可运行的类。</p></li>
<li><p>提供了一个内置的依赖管理器，设置依赖版本以匹配<a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-dependencies/pom.xml">Spring Boot依赖</a>。你可以覆盖为任何你希望的版本，但默认会使用Boot选择的版本。</p></li>
</ul>


<h3>使用Maven构建</h3>

<p>首先你需要设置一个基本的构建脚本。你可以使用任何构建系统来构建Spring应用程序，但这里包含了<a href="https://maven.apache.org/">Maven</a>的代码。如果你对Maven不熟，请访问<a href="http://spring.io/guides/gs/maven">使用Maven构建Java项目</a>。</p>

<h4>创建目录结构</h4>

<p>在你选择的存放项目的目录中，创建如下的子目录结构。例如，在*nix系统中使用<code>mkdir -p src/main/java/hello</code>。</p>

<pre><code class="text">
└── src
    └── main
        └── java
            └── hello
</code></pre>

<pre><code class="xml pom.xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;gs-consuming-web-service&lt;/artifactId&gt;
    &lt;version&gt;0.1.0&lt;/version&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;1.1.6.RELEASE&lt;/version&gt;
    &lt;/parent&gt;

    &lt;properties&gt;
        &lt;!-- use UTF-8 for everything --&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.ws&lt;/groupId&gt;
            &lt;artifactId&gt;spring-ws-core&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.3.2&lt;/version&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
            &lt;!-- tag::wsdl[] --&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.jvnet.jaxb2.maven2&lt;/groupId&gt;
                &lt;artifactId&gt;maven-jaxb2-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;generate&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
                &lt;configuration&gt;
                    &lt;schemaLanguage&gt;WSDL&lt;/schemaLanguage&gt;
                    &lt;generatePackage&gt;hello.wsdl&lt;/generatePackage&gt;
                    &lt;forceRegenerate&gt;true&lt;/forceRegenerate&gt;
                    &lt;schemas&gt;
                        &lt;schema&gt;
                            &lt;url&gt;http://wsf.cdyne.com/WeatherWS/Weather.asmx?wsdl&lt;/url&gt;
                        &lt;/schema&gt;
                    &lt;/schemas&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
            &lt;!-- end::wsdl[] --&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;spring-releases&lt;/id&gt;
            &lt;name&gt;Spring Releases&lt;/name&gt;
            &lt;url&gt;http://repo.spring.io/libs-release&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;pluginRepositories&gt;
        &lt;pluginRepository&gt;
            &lt;id&gt;spring-releases&lt;/id&gt;
            &lt;url&gt;http://repo.spring.io/libs-release&lt;/url&gt;
        &lt;/pluginRepository&gt;
    &lt;/pluginRepositories&gt;

&lt;/project&gt;
</code></pre>

<blockquote><p>注意：你可能注意到我们指定了<em>maven-complier-plugin</em>的版本。通常并<em>不推荐</em>这样做。这里主要是为了解决我们的CI系统默认运行在该插件的早期版本（java5之前）的一个问题。</p></blockquote>

<p><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-tools/spring-boot-maven-plugin">Spring Boot Maven插件</a>提供了很多便利的特性：</p>

<ul>
<li><p>将classpath中的所有jar包构建单个可运行的jar包，从而更容易执行和传播服务。</p></li>
<li><p>搜索<code>public static void main（）</code>方法并标记为可运行的类。</p></li>
<li><p>提供了一个内置的依赖管理器，设置依赖版本以匹配<a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-dependencies/pom.xml">Spring Boot依赖</a>。你可以覆盖为任何你希望的版本，但默认会使用Boot选择的版本。</p></li>
</ul>


<h3>使用Spring工具集构建</h3>

<p>如果你拥有Spring工具集，只需简单的<a href="http://spring.io/guides/gs/sts/">直接导入该指南</a>。</p>

<blockquote><p>注意:如果你阅读过生成SOAP web service,你可能会疑惑为什么该指南没有使用<strong>spring-boot-starter-ws</strong>?这是因为Spring Boot Starter只用于服务器端程序。Starter提供了诸如嵌入式Tomcat等功能，而服务调用则不需要这些。</p></blockquote>

<h3>基于WSDL生成领域对象</h3>

<p>SOAP web service的接口描述在<a href="http://en.wikipedia.org/wiki/Web_Services_Description_Language">WSDL</a>文件中。JAXB提供了一个简单的方式来从WSDL（或者WSDL中包含在<code>&lt;Types/&gt;</code>节点中的XSD）生成Java类。可以访问<a href="http://wsf.cdyne.com/WeatherWS/Weather.asmx?wsdl">http://wsf.cdyne.com/WeatherWS/Weather.asmx?wsdl</a>获取该天气服务的WSDL。</p>

<p>你需要下列插件来使用maven从WSDL生成Java类：</p>

<pre><code class="xml">
&lt;plugin&gt;
    &lt;groupId&gt;org.jvnet.jaxb2.maven2&lt;/groupId&gt;
    &lt;artifactId&gt;maven-jaxb2-plugin&lt;/artifactId&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;generate&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;configuration&gt;
        &lt;schemaLanguage&gt;WSDL&lt;/schemaLanguage&gt;
        &lt;generatePackage&gt;hello.wsdl&lt;/generatePackage&gt;
        &lt;forceRegenerate&gt;true&lt;/forceRegenerate&gt;
        &lt;schemas&gt;
            &lt;schema&gt;
                &lt;url&gt;http://wsf.cdyne.com/WeatherWS/Weather.asmx?wsdl&lt;/url&gt;
            &lt;/schema&gt;
        &lt;/schemas&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>

<p>该代码将通过指定的WSDL的URL生成类，并放置在<code>hello.wsdl</code>包中。</p>

<p>你也可以使用下列代码在Gradle中完成同样的事：</p>

<pre><code class="groovy">
task genJaxb {
    ext.sourcesDir = "${buildDir}/generated-sources/jaxb"
    ext.classesDir = "${buildDir}/classes/jaxb"
    ext.schema = "http://wsf.cdyne.com/WeatherWS/Weather.asmx?wsdl"

    outputs.dir classesDir

    doLast() {
        project.ant {
            taskdef name: "xjc", classname: "com.sun.tools.xjc.XJCTask",
                    classpath: configurations.jaxb.asPath
            mkdir(dir: sourcesDir)
            mkdir(dir: classesDir)

            xjc(destdir: sourcesDir, schema: schema,
                    package: "hello.wsdl") {
                arg(value: "-wsdl")
                produces(dir: sourcesDir, includes: "**/*.java")
            }

            javac(destdir: classesDir, source: 1.6, target: 1.6, debug: true,
                    debugLevel: "lines,vars,source",
                    classpath: configurations.jaxb.asPath) {
                src(path: sourcesDir)
                include(name: "**/*.java")
                include(name: "*.java")
            }

            copy(todir: classesDir) {
                fileset(dir: sourcesDir, erroronmissingdir: false) {
                    exclude(name: "**/*.java")
                }
            }
        }
    }
}
</code></pre>

<p>由于gradle还没有jaxb插件，所以它调用了一个ant任务，代码看起来比maven稍显复杂。
在maven和gradle两个示例中，JAXB领域对象生成过程被包括在构建工具的生命周期中，所以无需额外步骤来运行。</p>

<h3>创建天气服务客户端</h3>

<p>创建一个web service客户端，你只需要扩展<code>WebServiceGatewaySupport</code>类并编写操作代码：</p>

<pre><code class="java src/main/java/hello/WeatherClient.java">

package hello;

import java.text.SimpleDateFormat;

import org.springframework.ws.client.core.support.WebServiceGatewaySupport;
import org.springframework.ws.soap.client.core.SoapActionCallback;

import hello.wsdl.Forecast;
import hello.wsdl.ForecastReturn;
import hello.wsdl.GetCityForecastByZIP;
import hello.wsdl.GetCityForecastByZIPResponse;
import hello.wsdl.Temp;

public class WeatherClient extends WebServiceGatewaySupport {

    public GetCityForecastByZIPResponse getCityForecastByZip(String zipCode) {
        GetCityForecastByZIP request = new GetCityForecastByZIP();
        request.setZIP(zipCode);

        System.out.println();
        System.out.println("Requesting forecast for " + zipCode);

        GetCityForecastByZIPResponse response = (GetCityForecastByZIPResponse) getWebServiceTemplate().marshalSendAndReceive(
                request,
                new SoapActionCallback(
                        "http://ws.cdyne.com/WeatherWS/GetCityForecastByZIP"));

        return response;
    }

    public void printResponse(GetCityForecastByZIPResponse response) {
        ForecastReturn forecastReturn = response.getGetCityForecastByZIPResult();

        if (forecastReturn.isSuccess()) {
            System.out.println();
            System.out.println("Forecast for " + forecastReturn.getCity() + ", "
                    + forecastReturn.getState());

            SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
            for (Forecast forecast : forecastReturn.getForecastResult().getForecast()) {
                System.out.print(format.format(forecast.getDate().toGregorianCalendar().getTime()));
                System.out.print(" ");
                System.out.print(forecast.getDesciption());
                System.out.print(" ");
                Temp temperature = forecast.getTemperatures();
                System.out.print(temperature.getMorningLow() + "\u00b0-"
                        + temperature.getDaytimeHigh() + "\u00b0 ");
                System.out.println();
            }
        } else {
            System.out.println("No forecast received");
        }
    }

}
</code></pre>

<p>该客户端包含了两个方法。<code>getCityForecastByZip</code>用于实际的SOAP交换;<code>printResponse</code>打印收到的响应结果。我们重点关注第一个方法。</p>

<p>在该方法中，<code>GetCityForecastByZIP</code>及<code>GetCityForecastByZIPResponse</code>类衍生于WSDL中，被前一个步骤描述过的JAXB生成。该方法创建了<code>GetCityForecastByZIP</code>请求对象并设置了<code>zipCode</code>参数。打印出邮编后，使用WebServiceGatewaySupport基类提供的<a href="http://docs.spring.io/spring-ws/sites/2.0/apidocs/org/springframework/ws/client/core/WebServiceTemplate.html">WebServiceTemplate</a>来进行实际的SOAP交换。它传入<code>GetCityForecastByZIP</code>请求对象，以及一个<code>SoapActionCallback</code>来传入<a href="http://www.w3.org/TR/2000/NOTE-SOAP-20000508/#_Toc478383528">SOAPAction</a>头，因为WSDL说明其需要在<code>&lt;soap:operation/&gt;</code>元素中使用该头。该方法将返回值转换为<code>GetCityForecastByZIPResponse</code>对象，然后返回该对象。</p>

<h3>配置web service组件</h3>

<p>Spring WS使用了Spring框架的OXM模块。该模块拥有<code>Jaxb2Marshaller</code>类来序列化和反序列化XML请求。</p>

<pre><code class="java src/main/java/hello/WeatherConfiguration.java">
package hello;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.oxm.jaxb.Jaxb2Marshaller;

@Configuration
public class WeatherConfiguration {

    @Bean
    public Jaxb2Marshaller marshaller() {
        Jaxb2Marshaller marshaller = new Jaxb2Marshaller();
        marshaller.setContextPath("hello.wsdl");
        return marshaller;
    }

    @Bean
    public WeatherClient weatherClient(Jaxb2Marshaller marshaller) {
        WeatherClient client = new WeatherClient();
        client.setDefaultUri("http://wsf.cdyne.com/WeatherWS/Weather.asmx");
        client.setMarshaller(marshaller);
        client.setUnmarshaller(marshaller);
        return client;
    }

}
</code></pre>

<p><code>marshaller</code>被指向了生成的领域对象集合，将使用这些对象来实现XML和POJO之间的序列化和反序列化。</p>

<p>我们使用了上面显示的天气服务URI创建和配置了<code>weatherClient</code>。他也被配置使用JAXB marshaller。</p>

<h3>生成可执行的应用程序</h3>

<p>该应用程序被打包后可运行与命令行，传入一个邮编则会得到一个天气预报。</p>

<pre><code class="java src/main/java/hello/Application.java">
package hello;

import org.springframework.boot.SpringApplication;
import org.springframework.context.ApplicationContext;

import hello.wsdl.GetCityForecastByZIPResponse;

public class Application {

    public static void main(String[] args) {
        ApplicationContext ctx = SpringApplication.run(WeatherConfiguration.class, args);

        WeatherClient weatherClient = ctx.getBean(WeatherClient.class);

        String zipCode = "94304";
        if (args.length &gt; 0) {
            zipCode = args[0];
        }
        GetCityForecastByZIPResponse response = weatherClient.getCityForecastByZip(zipCode);
        weatherClient.printResponse(response);
    }

}
</code></pre>

<p><code>main()</code>方法调用了<code>SpringApplication</code>辅助方法，并向其<code>run()</code>方法传入了<code>WeatherConfiguration.class</code>参数。这会使<code>Spring从WeatherConfiguration</code>中读取注解元数据，并作为<a href="http://spring.io/understanding/application-context">Spring应用程序上下文中</a>的一个组件进行管理。</p>

<blockquote><p>注意:该应用程序硬编码了邮编94304，Palo Alto, CA。在该指南的最后，你可以看到如何添加不同的邮编而不用修改代码。</p></blockquote>

<h3>构建可执行的jar包</h3>

<p>你可以创建一个包含所有必须的依赖，类，及资源的可执行的JAR文件。这很方便传输，版本管理以及独立于部署生命周期来部署服务，跨不同的环境，诸如此类。</p>

<pre><code class="bash">
gradlew build
</code></pre>

<p>然后你可以运行WAR文件：</p>

<pre><code class="bash">
java -jar build/libs/gs-consuming-web-service-0.1.0.jar
</code></pre>

<p>如果你使用的是maven，你可以使用<code>mvn spring-boot:run</code>来运行程序，或者你可以使用<code>mvn clean package</code>构建JAR文件，并使用下面命令来运行：</p>

<pre><code class="bash">
java -jar target/gs-consuming-web-service-0.1.0.jar
</code></pre>

<blockquote><p>注意：上面的产出物是一个可运行JAR文件。你也可以<a href="http://spring.io/guides/gs/convert-jar-to-war/">创建一个经典的WAR文件</a>。　</p></blockquote>

<h3>运行服务</h3>

<p>如果使用的是Gradle，可以使用以下命令来运行服务：</p>

<pre><code class="bash">
gradlew clean build &amp;&amp; java -jar build/libs/gs-consuming-web-service-0.1.0.jar
</code></pre>

<blockquote><p>注意：如果你使用的是Maven，可以使用以下命令来运行服务：<code>mvn clean package &amp;&amp; java -jar target/gs-consuming-web-service-0.1.0.jar</code>。</p></blockquote>

<p>你也可以通过Gradle直接运行该程序：</p>

<pre><code class="bash">
gradlew bootRun
</code></pre>

<blockquote><p>注意：使用mvn的话，命令是<code>mvn spring-boot:run</code>。</p></blockquote>

<p>可以看到日志输出。该服务应该在几秒钟内启动并运行起来。</p>

<pre><code class="text">
Requesting forecast for 94304

Forecast for Palo Alto, CA
2013-01-03 Partly Cloudy °-57°
2013-01-04 Partly Cloudy 41°-58°
2013-01-05 Partly Cloudy 41°-59°
2013-01-06 Partly Cloudy 44°-56°
2013-01-07 Partly Cloudy 41°-60°
2013-01-08 Partly Cloudy 42°-60°
2013-01-09 Partly Cloudy 43°-58°
</code></pre>

<p>你也可以使用不同的邮编：<code>java -jar build/libs/gs-consuming-web-service-0.1.0.jar 34769</code></p>

<pre><code class="text">
Requesting forecast for 34769

Forecast for Saint Cloud, FL
2014-02-18 Sunny 51°-79°
2014-02-19 Sunny 55°-81°
2014-02-20 Sunny 59°-84°
2014-02-21 Partly Cloudy 63°-85°
2014-02-22 Partly Cloudy 63°-84°
2014-02-23 Partly Cloudy 63°-82°
2014-02-24 Partly Cloudy 62°-80°
</code></pre>

<h3>总结</h3>

<p>恭喜你！你开发了一个客户端来使用Spring调用一个基于SOAP的web service。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻译-使用Spring WebService生成SOAP web service]]></title>
    <link href="http://www.huangbowen.net/blog/2014/09/05/producing-web-service-using-spring/"/>
    <updated>2014-09-05T17:50:02+08:00</updated>
    <id>http://www.huangbowen.net/blog/2014/09/05/producing-web-service-using-spring</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://spring.io/guides/gs/producing-web-service/">http://spring.io/guides/gs/producing-web-service/</a></p>

<h2>生成SOAP web service</h2>

<p>该指南将带领你使用Spring创建一个基于SOAP的web service的整个过程。</p>

<!-- more -->


<h3>指南内容</h3>

<p>你将创建一个服务，该服务通过一个基于WSDL的SOAP web service向外暴露欧洲国家的数据。</p>

<blockquote><p>　注意：为了简化该示例，你将使用硬编码方式嵌入英国，西班牙及波兰。</p></blockquote>

<h3>准备事项</h3>

<ul>
<li><p>15分钟</p></li>
<li><p>喜爱的编辑器或IDE</p></li>
<li><p>JDK1.6或更高版本</p></li>
<li><p>Gradle 1.11+或Maven 3.0+</p></li>
<li><p>你也可以直接通过该指南导入代码，或通过Spring工具集（Spring Tool Suite，简称STS)通过网页浏览代码，从而帮助你学习该章节内容。源码下载地址： <a href="https://github.com/spring-guides/gs-producing-web-service.git">https://github.com/spring-guides/gs-producing-web-service.git</a>。</p></li>
</ul>


<h3>如何完成该指南</h3>

<p>如同大多数的<a href="http://spring.io/guides">示例教程</a>一样，你可以从头开始并完成每个步骤，或者你也可以跳过已经熟悉的基础章节。无论怎样，最终你要得到可以工作的代码。</p>

<p>想<em>从头开始</em>，请移动到<a href="#scratch">使用Gradle构建</a>章节。</p>

<p>想<em>跳过基础部分</em>，请做以下事情：</p>

<ul>
<li><p><a href="https://github.com/spring-guides/gs-soap-service/archive/master.zip">下载</a>并解压该向导的源代码，或者使用<a href="http://spring.io/understanding/Git">Git</a>复制一份： <code>git clone https://github.com/spring-guides/gs-soap-service.git</code></p></li>
<li><p>切换到<code>gs-soap-service/initial</code></p></li>
<li><p>跳到<a href="#initial">添加Spring-WS依赖</a>章节。</p></li>
</ul>


<p>当完成后，你可以使用<code>gs-soap-service/complete</code>目录中的代码检查你的结果。</p>

<h3><a name="#scratch">使用Gradle构建</a></h3>

<p>首先你要设置一个基本的build脚本。当构建Spring应用程序时，你可以使用任何构建系统，但是这里只包括了使用<a href="https://maven.apache.org">Maven</a>和<a href="gradle.org">Gradle</a>的代码。如果你两者都不熟悉，请访问<a href="http://spring.io/guides/gs/gradle">使用Gradle构建Java项目</a>或<a href="http://spring.io/guides/gs/maven">使用Maven构建Java项目</a>。</p>

<h4>创建目录结构</h4>

<p>在你选择的存放项目的目录中，创建如下的子目录结构。例如，在*nix系统中使用<code>mkdir -p src/main/java/hello</code>。</p>

<pre><code class="text">
└── src
    └── main
        └── java
            └── hello
</code></pre>

<h4>创建Gradle 构建文件</h4>

<p>下面是一个<a href="https://github.com/spring-guides/gs-soap-service/blob/master/initial/build.gradle">初始的Gradle build文件</a>。</p>

<pre><code class="groovy build.gradle">
buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        maven { url "http://repo.spring.io/libs-release" }
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:1.1.5.RELEASE")
    }
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'spring-boot'

jar {
    baseName = 'gs-producing-web-service'
    version =  '0.1.0'
}

repositories {
    mavenLocal()
    mavenCentral()
    maven { url "http://repo.spring.io/libs-release" }
}

dependencies {
    compile("org.springframework.boot:spring-boot-starter-web")
}

task wrapper(type: Wrapper) {
    gradleVersion = '1.11'
}
</code></pre>

<p><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-tools/spring-boot-gradle-plugin">Spring Boot gradle插件</a>提供了很多便利的特性：</p>

<ul>
<li><p>将classpath中的所有jar包构建单个可运行的jar包，从而更容易执行和传播服务。</p></li>
<li><p>搜索<code>public static void main（）</code>方法并标记为可运行的类。</p></li>
<li><p>提供了一个内置的依赖管理器，设置依赖版本以匹配<a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-dependencies/pom.xml">Spring Boot依赖</a>。你可以覆盖为任何你希望的版本，但默认会使用Boot选择的版本。</p></li>
</ul>


<h3>使用Maven构建</h3>

<p>首先你需要设置一个基本的构建脚本。你可以使用任何构建系统来构建Spring应用程序，但这里包含了<a href="https://maven.apache.org/">Maven</a>的代码。如果你对Maven不熟，请访问<a href="http://spring.io/guides/gs/maven">使用Maven构建Java项目</a>。</p>

<h4>创建目录结构</h4>

<p>在你选择的存放项目的目录中，创建如下的子目录结构。例如，在*nix系统中使用<code>mkdir -p src/main/java/hello</code>。</p>

<pre><code class="text">
└── src
    └── main
        └── java
            └── hello
</code></pre>

<pre><code class="xml pom.xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;gs-producting-web-service&lt;/artifactId&gt;
    &lt;version&gt;0.1.0&lt;/version&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;1.1.5.RELEASE&lt;/version&gt;
    &lt;/parent&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;properties&gt;
        &lt;!-- use UTF-8 for everything --&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;start-class&gt;hello.Application&lt;/start-class&gt;
    &lt;/properties&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>

<blockquote><p>注意：你可能注意到我们指定了<em>maven-complier-plugin</em>的版本。通常并<em>不推荐</em>这样做。这里主要是为了解决我们的CI系统默认运行在该插件的早期版本（java5之前）的一个问题。</p></blockquote>

<p><a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-tools/spring-boot-maven-plugin">Spring Boot Maven插件</a>提供了很多便利的特性：</p>

<ul>
<li><p>将classpath中的所有jar包构建单个可运行的jar包，从而更容易执行和传播服务。</p></li>
<li><p>搜索<code>public static void main（）</code>方法并标记为可运行的类。</p></li>
<li><p>提供了一个内置的依赖管理器，设置依赖版本以匹配<a href="https://github.com/spring-projects/spring-boot/blob/master/spring-boot-dependencies/pom.xml">Spring Boot依赖</a>。你可以覆盖为任何你希望的版本，但默认会使用Boot选择的版本。</p></li>
</ul>


<h3>使用Spring工具集构建</h3>

<p>如果你拥有Spring工具集，只需简单的<a href="http://spring.io/guides/gs/sts/">直接导入该指南</a>。</p>

<h3><a name="#initial">添加Spring-ws依赖</a></h3>

<p>你创建的项目需要添加<code>spring-ws-core</code>和wsdl4j依赖到构建文件中。</p>

<p>maven代码:</p>

<pre><code class="xml ">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-ws&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;wsdl4j&lt;/groupId&gt;
    &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt;
    &lt;version&gt;1.6.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>gradle代码：</p>

<pre><code class="groovy">
dependencies {
    compile("org.springframework.boot:spring-boot-starter-ws")
    compile("wsdl4j:wsdl4j:1.6.1")
    jaxb("com.sun.xml.bind:jaxb-xjc:2.2.4-1")
    compile(files(genJaxb.classesDir).builtBy(genJaxb))
}
</code></pre>

<h3>创建XML格式来定义领域对象</h3>

<p>该web service领域对象被定义在一个XML格式文件中（XSD），Spring-WS将自动导出为一个WSDL文件。</p>

<p>创建一个XSD文件，包含一个操作来返回一个国家的<em>名称</em>，<em>人口</em>，<em>首都</em>和<em>货币</em>。</p>

<pre><code class="xml src/main/resources/countries.xsd">
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:tns="http://spring.io/guides/gs-producing-web-service"
           targetNamespace="http://spring.io/guides/gs-producing-web-service" elementFormDefault="qualified"&gt;

    &lt;xs:element name="getCountryRequest"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name="name" type="xs:string"/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;

    &lt;xs:element name="getCountryResponse"&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name="country" type="tns:country"/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;

    &lt;xs:complexType name="country"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name="name" type="xs:string"/&gt;
            &lt;xs:element name="population" type="xs:int"/&gt;
            &lt;xs:element name="capital" type="xs:string"/&gt;
            &lt;xs:element name="currency" type="tns:currency"/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;

    &lt;xs:simpleType name="currency"&gt;
        &lt;xs:restriction base="xs:string"&gt;
            &lt;xs:enumeration value="GBP"/&gt;
            &lt;xs:enumeration value="EUR"/&gt;
            &lt;xs:enumeration value="PLN"/&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
&lt;/xs:schema&gt;
</code></pre>

<h3>　基于XML格式创建领域类</h3>

<p>接下来的步骤是根据XSD文件来创建java类。正确的方式是使用maven或gradle插件在构建时间自动创建。</p>

<p>maven插件配置;</p>

<pre><code class="xml">
&lt;plugin&gt;
    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
    &lt;artifactId&gt;jaxb2-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;1.6&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;xjc&lt;/id&gt;
            &lt;goals&gt;
                &lt;goal&gt;xjc&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;configuration&gt;
        &lt;schemaDirectory&gt;${project.basedir}/src/main/resources/&lt;/schemaDirectory&gt;
        &lt;outputDirectory&gt;${project.basedir}/src/main/java&lt;/outputDirectory&gt;
        &lt;clearOutputDir&gt;false&lt;/clearOutputDir&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre>

<p>生成的类放置在<code>target/generated-sources/jaxb</code>目录。</p>

<p>gradle插件配置如下，首先需要在构建文件中配置JAXB：</p>

<pre><code class="groovy">
configurations {
    jaxb
}

jar {
    baseName = 'gs-producing-web-service'
    version =  '0.1.0'
    from genJaxb.classesDir
}

// tag::dependencies[]
dependencies {
    compile("org.springframework.boot:spring-boot-starter-ws")
    compile("wsdl4j:wsdl4j:1.6.1")
    jaxb("com.sun.xml.bind:jaxb-xjc:2.2.4-1")
    compile(files(genJaxb.classesDir).builtBy(genJaxb))
}
// end::dependencies[]
</code></pre>

<blockquote><p>注意：上面的构建文件拥有tag及end注释。目的是为了能够在本指南中更容易抽取出来并做进一步解释。在你的构建文件中无需这些注释。</p></blockquote>

<p>接下来的步骤是添加任务<code>genJaxb</code>,该任务会生成java类：</p>

<pre><code class="groovy">
task genJaxb {
    ext.sourcesDir = "${buildDir}/generated-sources/jaxb"
    ext.classesDir = "${buildDir}/classes/jaxb"
    ext.schema = "src/main/resources/countries.xsd"

    outputs.dir classesDir

    doLast() {
        project.ant {
            taskdef name: "xjc", classname: "com.sun.tools.xjc.XJCTask",
                    classpath: configurations.jaxb.asPath
            mkdir(dir: sourcesDir)
            mkdir(dir: classesDir)

            xjc(destdir: sourcesDir, schema: schema) {
                arg(value: "-wsdl")
                produces(dir: sourcesDir, includes: "**/*.java")
            }

            javac(destdir: classesDir, source: 1.6, target: 1.6, debug: true,
                    debugLevel: "lines,vars,source",
                    classpath: configurations.jaxb.asPath) {
                src(path: sourcesDir)
                include(name: "**/*.java")
                include(name: "*.java")
            }

            copy(todir: classesDir) {
                fileset(dir: sourcesDir, erroronmissingdir: false) {
                    exclude(name: "**/*.java")
                }
            }
        }
    }
}
</code></pre>

<p>由于gradle还没有jaxb插件，所以它调用了一个ant任务，代码看起来比maven稍显复杂。</p>

<p>在maven和gradle两个示例中，JAXB领域对象生成过程被包括在构建工具的生命周期中，所以无需额外步骤来运行。</p>

<h3>创建国家仓库</h3>

<p>为了给web service提供数据，需要创建一个国家仓库，在本指南中创建了一个硬编码的伪造的国家仓库实现。</p>

<pre><code class="java">
package hello;

import javax.annotation.PostConstruct;
import java.util.ArrayList;
import java.util.List;

import io.spring.guides.gs_producing_web_service.Country;
import io.spring.guides.gs_producing_web_service.Currency;
import org.springframework.stereotype.Component;
import org.springframework.util.Assert;

@Component
public class CountryRepository {
    private static final List&lt;Country&gt; countries = new ArrayList&lt;Country&gt;();

    @PostConstruct
    public void initData() {
        Country spain = new Country();
        spain.setName("Spain");
        spain.setCapital("Madrid");
        spain.setCurrency(Currency.EUR);
        spain.setPopulation(46704314);

        countries.add(spain);

        Country poland = new Country();
        poland.setName("Poland");
        poland.setCapital("Warsaw");
        poland.setCurrency(Currency.PLN);
        poland.setPopulation(38186860);

        countries.add(poland);

        Country uk = new Country();
        uk.setName("United Kingdom");
        uk.setCapital("London");
        uk.setCurrency(Currency.GBP);
        uk.setPopulation(63705000);

        countries.add(uk);
    }

    public Country findCountry(String name) {
        Assert.notNull(name);

        Country result = null;

        for (Country country : countries) {
            if (name.equals(country.getName())) {
                result = country;
            }
        }

        return result;
    }
}
</code></pre>

<h3>创建国家服务终端</h3>

<p>为了创建一个service endpoint，x需要一个pojo对象，以及一些Spring WS注解来处理SOAP请求：</p>

<pre><code class="java">
package hello;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.ws.server.endpoint.annotation.Endpoint;
import org.springframework.ws.server.endpoint.annotation.PayloadRoot;
import org.springframework.ws.server.endpoint.annotation.RequestPayload;
import org.springframework.ws.server.endpoint.annotation.ResponsePayload;

import io.spring.guides.gs_producing_web_service.GetCountryRequest;
import io.spring.guides.gs_producing_web_service.GetCountryResponse;

@Endpoint
public class CountryEndpoint {
    private static final String NAMESPACE_URI = "http://spring.io/guides/gs-producing-web-service";

    private CountryRepository countryRepository;

    @Autowired
    public CountryEndpoint(CountryRepository countryRepository) {
        this.countryRepository = countryRepository;
    }

    @PayloadRoot(namespace = NAMESPACE_URI, localPart = "getCountryRequest")
    @ResponsePayload
    public GetCountryResponse getCountry(@RequestPayload GetCountryRequest request) {
        GetCountryResponse response = new GetCountryResponse();
        response.setCountry(countryRepository.findCountry(request.getName()));

        return response;
    }
}
</code></pre>

<p><code>@Endpoint</code>向Spring WS注册了该类为一个处理来临的SOAP消息的潜在对象。</p>

<p><code>@PayloadRoot</code> 被Spring WS用来根据消息的<em>命名空间</em>及<em>localPart</em>来选择处理该请求的方法。</p>

<p><code>@RequestPayload</code> 指明来临的消息将被映射到该方法的request参数。</p>

<p><code>@ResponsePayload</code>注解将使得Spring WS将返回值与响应负载映射起来。</p>

<blockquote><p>注意：在以上代码中，如果你没有运行任务来根据WSDL生成领域对象，那么在你的IDE中io.spring.guides类将会报告编译时错误。</p></blockquote>

<h3>配置web service bean</h3>

<p>使用Spring WS相关的bean配置选项创建一个新的类：</p>

<pre><code class="java">
package hello;

import org.springframework.boot.context.embedded.ServletRegistrationBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.ClassPathResource;
import org.springframework.ws.config.annotation.EnableWs;
import org.springframework.ws.config.annotation.WsConfigurerAdapter;
import org.springframework.ws.transport.http.MessageDispatcherServlet;
import org.springframework.ws.wsdl.wsdl11.DefaultWsdl11Definition;
import org.springframework.xml.xsd.SimpleXsdSchema;
import org.springframework.xml.xsd.XsdSchema;

@EnableWs
@Configuration
public class WebServiceConfig extends WsConfigurerAdapter {
    @Bean
    public ServletRegistrationBean dispatcherServlet(ApplicationContext applicationContext) {
        MessageDispatcherServlet servlet = new MessageDispatcherServlet();
        servlet.setApplicationContext(applicationContext);
        servlet.setTransformWsdlLocations(true);
        return new ServletRegistrationBean(servlet, "/ws/*");
    }

    @Bean(name = "countries")
    public DefaultWsdl11Definition defaultWsdl11Definition(XsdSchema countriesSchema) {
        DefaultWsdl11Definition wsdl11Definition = new DefaultWsdl11Definition();
        wsdl11Definition.setPortTypeName("CountriesPort");
        wsdl11Definition.setLocationUri("/ws");
        wsdl11Definition.setTargetNamespace("http://spring.io/guides/gs-producing-web-service");
        wsdl11Definition.setSchema(countriesSchema);
        return wsdl11Definition;
    }

    @Bean
    public XsdSchema countriesSchema() {
        return new SimpleXsdSchema(new ClassPathResource("countries.xsd"));
    }
}
</code></pre>

<ul>
<li><p>这里Spring WS使用了不同的servlet类型来处理SOAP消息：<code>MessageDispatcherServlet</code>。注入及设置<code>MessageDispatcherServlet</code>给<code>ApplicationContext</code>是非常重要的。如果不这样做，Spring WS无法自动检测到Spring bean。</p></li>
<li><p>通过给<code>dispatcherServlet</code> bean命名，<a href="http://docs.spring.io/spring-boot/docs/1.1.5.RELEASE/reference/htmlsingle/#howto-switch-off-the-spring-mvc-dispatcherservlet">替代</a>了Spring Boot中默认的<code>DispatcherServlet bean</code>。</p></li>
<li><p><code>DefaultMethodEndpointAdapter</code>配置了注解驱动的Spring WS编程模型。这使得使用前面提过的诸如<code>@Endpoint</code>等各种各样的注解成为可能。</p></li>
<li><p><code>DefaultWsdl11Defination</code>使用<code>XsdSchema</code>暴露了一个标准的WSDL 1.1。</p></li>
</ul>


<p>请注意你需要为<code>MessageDispatcherServlet</code>及<code>DefaultWsdl11Definition</code>制定bean名称，这是非常重要的。Bean名称决定了生成的WSDL文件在哪个web service是可用的。在本例中，WSDL可通过<code>http://&lt;host&gt;:&lt;port&gt;/ws/countries.wsdl</code>来访问。</p>

<p>该配置也使用了WSDL位置servlet转化<code>servlet.setTransformWsdlLocations(true)</code>。如果你访问<a href="http://localhost:8080/ws/countries.wsdl">http://localhost:8080/ws/countries.wsdl</a>，<code>soap：address</code>将拥有正确的值。如果你使用本机的公共IP来访问该WSDL，你将看到的是IP。</p>

<h3>创建该程序的可执行文件</h3>

<p>尽管我们可以将该程序打包成一个传统的<a href="http://spring.io/understanding/WAR">war包</a>并部署到一个外部的应用程序服务器中，但是最简单的方式还是下面所演示的，创建一个能独立运行的应用程序。你可以通过老但好用的java <code>main()</code>方法，将所有文件打包到单个可执行的jar包中。同时，可以借助于Spring的支持内置<a href="http://spring.io/understanding/Tomcat">Tomcat</a> servlet容器作为HTTP运行时，从而无需部署到外部的实例中。</p>

<pre><code class="java src/main/java/hello/Application.java">
package hello;

import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.SpringApplication;
import org.springframework.context.annotation.ComponentScan;

@ComponentScan
@EnableAutoConfiguration
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
</code></pre>

<p><code>main()</code>方法使用了<code>SpringApplication</code>辅助方法，将<code>Application.class</code>作为参数传递给其自身的<code>run（）</code>方法。这告诉Spring读取<code>Application</code>中的注解元数据，并将其作为<a href="http://spring.io/understanding/application-context">Spring 应用程序上下文</a>的组件。</p>

<p><code>@ComponentScan</code>注解告诉Spring递归搜索<code>hello</code>包及其子包中找到被直接或者间接使用了Spring的<code>@Component</code>注解的类。该指令确保了Spring发现并注册<code>CountryRepository</code>及<code>CountriesEndpoint</code>，因为他们被标记为<code>@Component</code>及<code>@Endpoint</code>，这是一种<code>@Component</code>注解。</p>

<p><code>@EnableAutoConfiguration</code>注解会基于classpath内容切换到默认的合理的行为。例如，由于应用程序依赖Tomcat的内置版本（tomcat-embed-core.jar），Spring会替你设置并配置一个默认的合理的Tomcat服务器。并且该程序还依赖Spring MVC（spring-webmvc.jar），Spring会配置并注册以恶搞Spring MVC <code>DispatcherServlet</code>，根本无需<code>web.xml</code>文件！自动配置是强大的，弹性的机制。请查看<a href="http://docs.spring.io/spring-boot/docs/1.1.5.RELEASE/api/org/springframework/boot/autoconfigure/EnableAutoConfiguration.html">API文档</a>获取更多细节。</p>

<h4>构建可执行的jar包</h4>

<p>你可以创建一个包含所有必须的依赖，类，及资源的可执行的JAR文件。这很方便传输，版本管理以及独立于部署生命周期来部署服务，跨不同的环境，诸如此类。</p>

<pre><code class="bash">
./gradlew build
</code></pre>

<p>然后你可以运行WAR文件：</p>

<pre><code class="bash">
java -jar build/libs/gs-soap-service-0.1.0.jar
</code></pre>

<p>如果你使用的是maven，你可以使用<code>mvn spring-boot:run</code>来运行程序，或者你可以使用<code>mvn clean package</code>构建JAR文件，并使用下面命令来运行：</p>

<pre><code class="bash">
java -jar target/gs-soap-service-0.1.0.jar
</code></pre>

<blockquote><p>注意：上面的产出物是以恶搞可运行JAR文件。你也可以<a href="http://spring.io/guides/gs/convert-jar-to-war/">创建一个经典的WAR文件</a>。</p></blockquote>

<h3>　运行服务</h3>

<p>如果使用的是Gradle，可以使用以下命令来运行服务：</p>

<pre><code class="bash">
./gradlew clean build &amp;&amp; java -jar build/libs/gs-soap-service-0.1.0.jar
</code></pre>

<p>注意：如果你使用的是Maven，可以使用以下命令来运行服务：<code>mvn clean package &amp;&amp; java -jar target/gs-soap-service-0.1.0.jar</code>。</p>

<p>你也可以通过Gradle直接运行该程序：</p>

<pre><code class="bash">
./gradlew bootRun
</code></pre>

<blockquote><p>注意：使用mvn的话，命令是<code>mvn spring-boot:run</code>。</p></blockquote>

<p>可以看到日志输出。该服务应该在几秒钟内启动并运行起来。</p>

<h3>　测试该程序</h3>

<p>现在该程序正在运行，你可以测试它。创建一个名为<code>request.xml</code>文件，包含以下的SOAP请求；</p>

<pre><code class="xml">
&lt;soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
                  xmlns:gs="http://spring.io/guides/gs-producing-web-service"&gt;
   &lt;soapenv:Header/&gt;
   &lt;soapenv:Body&gt;
      &lt;gs:getCountryRequest&gt;
         &lt;gs:name&gt;Spain&lt;/gs:name&gt;
      &lt;/gs:getCountryRequest&gt;
   &lt;/soapenv:Body&gt;
&lt;/soapenv:Envelope&gt;
</code></pre>

<p>有很多方式来测试该SOAP接口。你可以使用<a href="http://www.soapui.org/">SoapUI</a>等工具，或者如果你使用的是*nix/Mac系统的话，直接可以使用命令行，如下所示：</p>

<pre><code class="bash">
$ curl --header "content-type: text/xml" -d @request.xml http://localhost:8080/ws
</code></pre>

<p>你将看到如下的响应结果：</p>

<pre><code class="xml">
&lt;?xml version="1.0"?&gt;
&lt;SOAP-ENV:Envelope xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"&gt;
  &lt;SOAP-ENV:Header/&gt;
  &lt;SOAP-ENV:Body&gt;
    &lt;ns2:getCountryResponse xmlns:ns2="http://spring.io/guides/gs-producing-web-service"&gt;
      &lt;ns2:country&gt;
        &lt;ns2:name&gt;Spain&lt;/ns2:name&gt;
        &lt;ns2:population&gt;46704314&lt;/ns2:population&gt;
        &lt;ns2:capital&gt;Madrid&lt;/ns2:capital&gt;
        &lt;ns2:currency&gt;EUR&lt;/ns2:currency&gt;
      &lt;/ns2:country&gt;
    &lt;/ns2:getCountryResponse&gt;
  &lt;/SOAP-ENV:Body&gt;
&lt;/SOAP-ENV:Envelope&gt;
</code></pre>

<blockquote><p>注意：输出可能是一个紧凑的XML文档，而不是上面显示的格式友好的文档。如果系统中安装了xmllib2，可以使用<code>curl &lt;args above&gt; &gt; output.xml | xmllint --format output.xml</code>来查看格式友好的结果。</p></blockquote>

<h3>　总结</h3>

<p>恭喜你！你使用Spring Web Service开发完成了一个基于SOAP的服务。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用自定义的MessageSource实现对properties的复用]]></title>
    <link href="http://www.huangbowen.net/blog/2013/05/29/using-spring-message-source/"/>
    <updated>2013-05-29T14:48:00+08:00</updated>
    <id>http://www.huangbowen.net/blog/2013/05/29/using-spring-message-source</id>
    <content type="html"><![CDATA[<p>Spring框架的Web项目中可以使用properties文件来存储需要显示在jsp页面的一些值，比如label值或者error messages。然后通过Spring提供的ResourceBundleMessageSource将这些properties文件注入进来使用。一个简单的配置如下。</p>

<!-- more -->


<pre><code class="xml">
    &lt;bean id="messageSource"
          class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
        &lt;property name="basenames"&gt;
            &lt;list&gt;
                &lt;value&gt;labels&lt;/value&gt;
                &lt;value&gt;errors&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
</code></pre>

<p>而在我们的项目中有这样一个需求。假设现在项目中有三个properties文件。</p>

<p><img src="/images/properties.png"></p>

<p>其中aami和apia是我们项目需要支持的两个品牌。当一个用户登陆我们的web项目时，会自动将其当前所使用的品牌信息存到session中。而如果是aami用户的话，前端jsp页面显示的message读取的顺序是这样的：如果在aami.properties文件中没找到的话，就在default.properties文件中找。对于apia用户，则先在apia.properties中找，然后查找default.properties。</p>

<p>举个例子，如果default.properties中有一个键值对<code>helloWorld.label = Welcome</code>。那么在jsp上使用时会显示Welcome。但是对于ammi来说需要用同样的键<code>hello.world.label</code>但是显示<code>Welcome to AAMI</code>。</p>

<p>这样可以最大程度的复用default.properties中的数据，同时又可以根据自身品牌定义一些自身的数据在自身品牌的properties文件中。</p>

<p>ResourceBundleMessageSource中有一个<code>parentMessageSource</code>属性，如果在当前MessageSource中找不到code的值，会在<code>parentMessageSource</code>中查找。一个简单的配置如下。</p>

<pre><code class="xml">
    &lt;bean id="messageSource"
          class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
        &lt;property name="parentMessageSource"&gt;
            &lt;bean class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
                &lt;property name="basename"&gt;
                    &lt;value&gt;default&lt;/value&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
        &lt;property name="basenames"&gt;
            &lt;list&gt;
                &lt;value&gt;aami&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
</code></pre>

<p>如果给给定一个code，程序会先在aami.properties文件中查找，如果未找到，则会在default中查找。
这似乎能满足我们的要求。其实不行。假如我们现在将apia品牌也加入，如果想让程序根据当前用户的品牌来选择适合的properties做成首选,当前这个功能是不满足的。我们需要自定义一个继承自<code>ResourceBundleMessageSource</code>的类来实现。</p>

<pre><code class="java SessionMessageSource.java">
public class SessionMessageSource extends ResourceBundleMessageSource {

    static final Logger logger = LoggerFactory.getLogger(SessionMessageSource.class);

    private String[] basenames = new String[0];

    @Override
    protected String resolveCodeWithoutArguments(String code, Locale locale) {
        ServletRequestAttributes attr = (ServletRequestAttributes) RequestContextHolder.currentRequestAttributes();
        final String brand = (String) attr.getAttribute("brand", RequestAttributes.SCOPE_SESSION);

        logger.debug(brand);

        ArrayList&lt;String&gt; basenameList = Lists.newArrayList(basenames);

        for(String basename : basenameList) {
            if (StringUtils.endsWithIgnoreCase(basename,brand)) {
                ResourceBundle bundle = getResourceBundle(basename, locale);
                if (bundle != null) {
                    return getStringOrNull(bundle, code);
                }
            }
        }

        return null;
    }

    @Override
    public void setBasenames(String... basenames) {
        if (basenames != null) {
            this.basenames = new String[basenames.length];
            for (int i = 0; i &lt; basenames.length; i++) {
                String basename = basenames[i];
                Assert.hasText(basename, "Basename must not be empty");
                this.basenames[i] = basename.trim();
            }
        }
        else {
            this.basenames = new String[0];
        }
        super.setBasenames(basenames);
    }

    private String getStringOrNull(ResourceBundle bundle, String key) {
        try {
            return bundle.getString(key);
        }
        catch (MissingResourceException ex) {
            // Assume key not found
            // -&gt; do NOT throw the exception to allow for checking parent message source.
            return null;
        }
    }
}
</code></pre>

<p>我们首先重写了<code>setBeanNames</code>方法。该方法用于在配置文件中注入properties文件。之所以在这里拿到basenames是为了在<code>resolveCodeWithoutArguments</code>方法中使用。如果父类暴露了<code>basenames</code>属性我们就无需在自己的类中再记录这个属性。</p>

<p>此类重写了父类中的<code>resolveCodeWithoutArguments</code>方法。父类中该方法的职责是在查找自身的ResourceBundle中是否能找到对应code的值，如果找不到就返回null。由于<code>resolveCodeWithoutArguments</code>方法是被<code>getMessageInternal</code>方法调用的。而<code>getMessageInternal</code>方法的大概职责是查看自身的ResourceBundle能否找到code值，否则查找parentMessageSource。所以我们只需对<code>resolveCodeWithoutArguments</code>动手术即可。</p>

<p>在这个方法中，我们首先获取存储在session中的brand值，根据brand值找到对应的propeties文件，使用ResourceBundle来读取code值，如果未找到则返回null，以委托给getMessageInternal来找寻父MessageSource。这样可以有效地将不同的brand隔离开来。</p>

<p>那么在xml中的配置如下。</p>

<pre><code class="xml">
    &lt;bean id="messageSource"
          class="com.thoughtworks.config.SessionMessageSource"&gt;
        &lt;property name="parentMessageSource"&gt;
            &lt;bean class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
                &lt;property name="basename"&gt;
                    &lt;value&gt;default&lt;/value&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
        &lt;property name="basenames"&gt;
            &lt;list&gt;
                &lt;value&gt;aami&lt;/value&gt;
                &lt;value&gt;apia&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
</code></pre>

<p>此外还需要在适当的时候设置session。</p>

<pre><code class="java StartFlowController.java">
@Controller
public class StartFlowController {

    @RequestMapping(value= "/aami", method = RequestMethod.GET)
    public String onAAMIPage(HttpServletRequest request) {
        request.getSession().setAttribute("brand", "aami");
        return "redirect:aami/index";
    }

    @RequestMapping(value= "/apia", method = RequestMethod.GET)
    public String onAPIAPage(HttpServletRequest request) {
        request.getSession().setAttribute("brand", "apia");
        return "redirect:apia/index";
    }
}
</code></pre>

<p>这些代码可以在我的github中找到。地址是<a href="https://github.com/huangbowen521/SpringMessageSpike">https://github.com/huangbowen521/SpringMessageSpike</a>。</p>
]]></content>
  </entry>
  
</feed>
