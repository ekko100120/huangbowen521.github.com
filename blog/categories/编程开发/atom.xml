<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 编程开发 | 黄博文的地盘]]></title>
  <link href="http://www.huangbowen.net/blog/categories/编程开发/atom.xml" rel="self"/>
  <link href="http://www.huangbowen.net/"/>
  <updated>2013-03-13T11:31:04+08:00</updated>
  <id>http://www.huangbowen.net/</id>
  <author>
    <name><![CDATA[黄博文]]></name>
    <email><![CDATA[huangbowen521@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java基础学习之Enum]]></title>
    <link href="http://www.huangbowen.net/blog/2013/03/12/enum-in-java/"/>
    <updated>2013-03-12T22:17:00+08:00</updated>
    <id>http://www.huangbowen.net/blog/2013/03/12/enum-in-java</id>
    <content type="html"><![CDATA[<p>Enum是在Java中用来定义枚举类型的关键字。Enum一般用来表示一组相同类型的常量,如性别、日期 、颜色等.</p>

<p>下面是一个最简单的枚举。</p>

<p>```java
public enum Color
{</p>

<p>RED,</p>

<p>GREEN,</p>

<p>BLUE</p>

<p>}
```</p>

<p>实际上在Java中枚举类型本质上就是一个类，其继承自java.lang.Enum类。</p>

<p>通过默认提供的<code>GetValues()</code>方法可以获取所有枚举对象，其以一个数组的形式返回。</p>

<p>```java</p>

<p>for(Color color : Color.values())
{</p>

<p>System.out.printf("%s: %s%n",color,color.toString());</p>

<p>}</p>

<p>```</p>

<p>输出结果为：</p>

<p>```console</p>

<p>RED: RED</p>

<p>GREEN: GREEN</p>

<p>BLUE: BLUE</p>

<p>```</p>

<p>既然是enum本质上是类，那么我们当然可以给其加一些方法。注意最后一个枚举对象要使用“；”结尾，说明枚举值结束使用。</p>

<p>```java</p>

<p>public enum Color
{</p>

<p>RED("Red Color"),</p>

<p>GREEN("Green Color"),</p>

<p>BLUE("Blue Color");</p>

<p>private final String color;</p>

<p>private Color(String color) {</p>

<pre><code>this.color = color;
</code></pre>

<p>}</p>

<p>public String getColor() {</p>

<p>return color;</p>

<p>}</p>

<p>}</p>

<p>```</p>

<p>注意在enum中是不能声明public的构造函数的，这样是为了避免直接实例化enum对象。</p>

<p>我们可以通过<code>getValues()</code>方法调用<code>getColor()</code>方法。</p>

<p>```java</p>

<p>for(Color color : Color.values())
{</p>

<p>System.out.printf("%s: %s%n",color,color.getColor());</p>

<p>}</p>

<p>```</p>

<p>以下是输出结果：</p>

<p>```console</p>

<p>RED: Red Color</p>

<p>GREEN: Green Color</p>

<p>BLUE: Blue Color</p>

<p>```</p>

<p>如果大家还是看不太明白的话，我可以展示一个类来对个对比。</p>

<p>```java</p>

<p>public final class Color extends java.lang.Enum{</p>

<pre><code>public static final Color RED;

public static final Color GREEN;

public static final Color  BLUE;

static {};

public java.lang.String getColor();

public static Color[] values();

public static Color valueOf(java.lang.String);
</code></pre>

<p>}</p>

<p>```</p>

<p>这个类的作用等同于我们的Color枚举对象。而每个被枚举的成员其实就是定义的枚举类型的一个实例，它们都被默认为final。无法改变常数名称所设定的值，它们也是public和static的成员，这与接口中的常量限制相同。可以通过类名称直接使用它们。</p>

<p>所以我们大胆的在里面增加一些其它的方法来实现我们的新特性。</p>

<p>在这里我增加了一个新的方法isRed()来判断当前枚举实例是否是红色的。</p>

<p>```java</p>

<p>public enum Color
{</p>

<p>RED("Red Color"),</p>

<p>GREEN("Green Color"),</p>

<p>BLUE("Blue Color");</p>

<p>private final String color;</p>

<p>private Color(String color) {</p>

<pre><code>this.color = color;
</code></pre>

<p>}</p>

<p>public String getColor() {</p>

<p>return color;</p>

<p>}</p>

<p>public boolean isRed() {</p>

<p>return this.equals(RED);</p>

<p>}</p>

<p>}</p>

<p>```</p>

<p>可以对其进行一个测试。</p>

<p>```java</p>

<p>Color green = Color.GREEN;</p>

<p>System.out.print(green.isRed());</p>

<p>Color red = Color.RED;</p>

<p>System.out.print(red.isRed());</p>

<p>```</p>

<p>第一个输出结果为false，第二个输出结果为true。</p>

<p>通过对Java中enum的运用，往往会产生奇效。比如有这样一个例子，有一个Rover对象，它有一个类型为Enum的direction属性，我们要给Rover实现左转的指令。你可能会写出这样的代码：</p>

<p>```java Direction.java</p>

<p>public enum Direction {</p>

<pre><code>North,
East,
South,
West
</code></pre>

<p>}</p>

<p><code>
</code>java Rover.java</p>

<p>public class Rover {</p>

<pre><code>private Direction direction;

public Rover(Direction direction) {
    this.direction = direction;
}

public void turnLeft() {
    if (direction.equals(Direction.East)) {
        direction = Direction.North;
    } else if (direction.equals(Direction.North)) {
        direction = Direction.West;
    } else if (direction.equals(Direction.West)) {
        direction = Direction.South;
    } else if (direction.equals(Direction.South)) {
        direction = Direction.East;
    }

}
</code></pre>

<p>}</p>

<p><code>``
一大堆</code>if...else`的代码看起来真的很丑陋。这还好，如果让你给Rover再加几个方法，比如向右转，旋转到反方向等，那代码就没法看了。
我们可以这样分析一下，其实给定一个方向之后，向左转的方向也就确定了，所以我们可以将这些逻辑放置到Direction对象中去。下面是改进后的版本。</p>

<p>```java Direction.java</p>

<p>public enum Direction {</p>

<pre><code>North {
    @Override
    public Direction turnLeft() {
    return West;
    }
},
East {
    @Override
    public Direction turnLeft() {
        return North;
    }

},
South {
    @Override
    public Direction turnLeft() {
        return East;
    }
},
West {
    @Override
    public Direction turnLeft() {
        return South;
    }
};

public abstract Direction turnLeft();
</code></pre>

<p>}</p>

<p>```</p>

<p>```java Rover.java</p>

<p>public class Rover {</p>

<pre><code>private Direction direction;

public Rover(Direction direction) {
    this.direction = direction;
}

public void turnLeft() {
    direction = direction.turnLeft();
}
</code></pre>

<p>}</p>

<p>```</p>

<p>这样的代码看起来要舒服的多.</p>

<h2>C#中的Enum</h2>

<p>我也可以简单的讲解下c#中的枚举对象。在c#中声明枚举对象的关键字是enum。</p>

<p>```c#</p>

<p> 访问修辞符 enum 枚举名:基础类型</p>

<pre><code>{
    枚举成员
}
</code></pre>

<p>```</p>

<p>基础类型必须能够表示该枚举中定义的所有枚举数值。枚举声明可以显式地声明 byte、sbyte、short、ushort、int、uint、long 或 ulong 类型作为对应的基础类型。没有显式地声明基础类型的枚举声明意味着所对应的基础类型是 int.</p>

<p>```c#</p>

<p>public enum Color</p>

<p>{</p>

<p>RED,</p>

<p>GREEN,</p>

<p>BLUE</p>

<p>}</p>

<p>```</p>

<p>所以我们可以直接将一个枚举类型强制转换成其对应的基础类型。</p>

<p><code>c#
Int  num = (int)Color.Red;
</code></p>

<p>Num的值为0.</p>

<p>我们也可以反向转换。</p>

<p>```c#</p>

<p>Color color = (Color)num;</p>

<p>```</p>

<p>甚至我们还可以对枚举类型进行与或运算。这些就不细说了，有兴趣的可以查阅相关资料。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Haskell-函数式编程语言之初体验]]></title>
    <link href="http://www.huangbowen.net/blog/2013/03/02/haskell-programming-language-first-touch/"/>
    <updated>2013-03-02T14:55:00+08:00</updated>
    <id>http://www.huangbowen.net/blog/2013/03/02/haskell-programming-language-first-touch</id>
    <content type="html"><![CDATA[<p>如果你是使用面向对像语言进行编程的程序员，那么你应该去了解掌握一门动态语言。而动态语言的魔力之一就是函数式编程。而要学习了解函数式编程，那么haskell是一个不错的选择。</p>

<p>Haskell是是一门纯函数式编程语言(purely functional programming language)。在其世界中函数是第一等对象。并且在haskell中没有赋值，例如你指派a的值为5，然后你无法再给a分配其它的值。所以你不能像命令式语言那样命令电脑“要做什么”，而是通过函数来描述出问题“是什么”。</p>

<p>作为一个纯的函数式编程语言，它支持惰性求值、模式匹配、列表解析、类型类、类型多态……</p>

<p>别着急，让我们慢慢来解开函数式编程的面纱。</p>

<h2>安装Haskell</h2>

<ol>
<li><p>可以去<a href="http://www.Haskell.org/Haskellwiki/Haskell">官网</a>下载安装包进行安装。</p></li>
<li><p>mac平台的用户可以通过<a href="http://mxcl.github.com/homebrew/">homebrew</a>进行安装。</p></li>
</ol>


<p>在terminal下输入<code>brew install haskell-platform</code>即可。</p>

<h2>使用Haskell</h2>

<p>安装完毕后haskell platform的解释器GHC就已经在你的电脑上了。GHC可以解释执行Haskell脚本，即后缀名为.hs的文件。你可可以通过在terminal输入<code>ghci</code>进入交互模式。</p>

<p>``` bash</p>

<p>twer@bowen-huang:~$ ghci
GHCi, version 7.4.2: http://www.haskell.org/ghc/ :? for help
Loading package ghc-prim ... linking … done.
Loading package integer-gmp ... linking … done.
Loading package base ... linking … done.
Prelude> 1+2
3
Prelude> 3*4
12
Prelude> 5/1
5.0</p>

<p>```</p>

<p>关于Haskell的编辑器你可以使用任何喜欢的编辑器:Vim、Emacs、Sublime、TextMate…..我比较喜欢Sublime。因为在Sublime自带Haskell的快捷编译执行。只需要按Ctrl+B来直接运行Scripts脚本。</p>

<p>在ghci交互模式下可以使用<code>:l</code>命令来load一个Haskell脚本，然后就可以调用此脚本中的函数。我们先写一个'Hello world!’程序，然后通过ghci来load和调用.</p>

<p>``` haskell HelloWorld.hs</p>

<p>main = print $ "Hello world!"</p>

<p>```</p>

<p>``` bash
Prelude> :l HelloWorld.hs
[1 of 1] Compiling Main ( HelloWorld.hs, interpreted )
Ok, modules loaded: Main.
*Main> main
"Hello world!"</p>

<p>```</p>

<p>如果对文件进行了修改，也可以直接通过<code>:r</code>来重新加载文件。</p>

<h2>Haskell的基本语法</h2>

<h3>加减乘除操作</h3>

<p>``` bash</p>

<p>Prelude> 1 + 2
3
Prelude> 3 - 1
2
Prelude> 3 * 4
12
Prelude> 5 / 1
5.0
Prelude> 10 / (-5)
-2.0</p>

<p>```</p>

<p>注意对负数进行操作时要将其用()括起来，否则系统会报错。</p>

<h3>判等与比较操作</h3>

<p>``` bash</p>

<p>Prelude> 5 == 5
True
Prelude> 10 == 8
False
Prelude> 5 /= 5
False
Prelude> 10 /= 8
True
Prelude> 5 >= 3
True
Prelude> 5 &lt;= 3
False
Prelude> True &amp;&amp; True
True
Prelude> True &amp;&amp; False
False
Prelude> False || False
False
Prelude> True || False
True
Prelude> not True
False
Prelude> not False
True</p>

<p>```</p>

<h3>控制流转</h3>

<p>``` bash</p>

<p>Prelude> let isHello x = if x == "Hello" then True else False
Prelude> isHello "Hello"
True
Prelude> isHello "World"
False</p>

<p>```</p>

<p>注意这里的条件判断中的else是不可以省略的，这样保证条件语句总会返回一个值。所以我们可以将整个<code>if..then..else</code> pattern看做一个表达式。</p>

<p>如果在脚本文件中写的话不需要使用<code>let</code>关键字。并且也可以采用另一个写法。</p>

<p>``` haskell isHello.hs</p>

<p>isHello x
 | x == "Hello" = True
 | otherwise     = False</p>

<p>```</p>

<p>|表示或，otherwise关键字表示其它的情况。当然你也可以将这三行代码写成一行，这样也是能够正常运行的。分成三行只是为了更加可读。</p>

<p>还有第三种写法，实际上与面对对象语言中的<code>switch…case</code>语句有些类似。</p>

<p>``` haskell isHello.hs</p>

<p>isHello x = case x of
 "Hello" -> True
 otherwise -> False</p>

<p>```</p>

<p>这和第二种写法很类似。其实第二种写法本质上就是<code>case</code>语句，它只是<code>case</code>语句的一个语法糖而已。</p>

<p>另外，在Haskell中是没有各种循环语句的，如果要实现相似的特性当然要使用递归了。</p>

<p>第二节中，我们会讨论这个问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[避免每次输入bundler exec命令]]></title>
    <link href="http://www.huangbowen.net/blog/2013/02/04/bi-mian-mei-ci-shu-ru-bundler-execming-ling/"/>
    <updated>2013-02-04T00:24:00+08:00</updated>
    <id>http://www.huangbowen.net/blog/2013/02/04/bi-mian-mei-ci-shu-ru-bundler-execming-ling</id>
    <content type="html"><![CDATA[<p>bundle在ruby的世界里是个好东西，它可以用来管理应用程序的依赖库。它能自动的下载和安装指定的gem，也可以随时更新指定的gem。</p>

<p><a href="https://rvm.io/">rvm</a>则是一个命令行工具，能帮助你轻松的安装，管理多个ruby环境。每个环境可以指定一系列的gem。它允许你为每一个项目指定其ruby的版本，需要的gem的版本。这能最大限度的避免由于ruby环境的差异，或者不同版本的gem造成的各种问题。</p>

<p>当我在项目中引入了rvm后，使用rake命令时，每次都会出现这样的异常。</p>

<p><code>bash
rake aborted!
You have already activated rake 10.0.0, but your Gemfile requires rake 0.9.2.2. Using bundle exec may solve this.
/usr/local/rvm/gems/ruby-1.9.3-p194/gems/bundler-1.2.3/lib/bundler/runtime.rb:31:in `block in setup'
/usr/local/rvm/gems/ruby-1.9.3-p194/gems/bundler-1.2.3/lib/bundler/runtime.rb:17:in `setup'
/usr/local/rvm/gems/ruby-1.9.3-p194/gems/bundler-1.2.3/lib/bundler.rb:116:in `setup'
/usr/local/rvm/gems/ruby-1.9.3-p194/gems/bundler-1.2.3/lib/bundler/setup.rb:7:in `&lt;top (required)&gt;'
/Users/twer/sourcecode/octopress/Rakefile:2:in `&lt;top (required)&gt;'
(See full trace by running task with --trace)
</code></p>

<p>从这个异常中我们可以看到，由于我在自己机器上已经安装了rake的<code>10.0.0</code>版本，但是这个项目中配置的rake版本却是<code>0.9.2.2</code>，所以在执行rake命令时应该使用Gemfile的。</p>

<p>而<code>bundle exec</code>可以在当前bundle的上下文中执行一段脚本。通过它可以调用本项目中指定的rake版本来执行命令。</p>

<p>下面是官方文档的说明。</p>

<blockquote><p>In some cases, running executables without bundle exec may work, if the executable happens to be installed in your system and does not pull in any gems that conflict with your bundle. However, this is unreliable and is the source of considerable pain. Even if it looks like it works, it may not work in the future or on another machine.</p></blockquote>

<p>所以我们只要每次执行命令的时候加上<code>bundle exec</code>的前缀就可以额。但是这样搞的很烦人，试想每天都要敲上百次这样的字符，而且还常常忘记。</p>

<p>有一个方法可以避免每次都要键入<code>bundle exec</code>作为前缀。</p>

<p>安装<a href="https://github.com/mpapis/rubygems-bundler">rubygems-bundler</a>。
<code>bash
$ gem install rubygems-bundler
</code>
然后运行：
<code>bash
$ gem regenerate_binstubs
</code></p>

<p>启用RVM hook:
<code>bash
$ rvm get head &amp;&amp; rvm reload
$ chmod +x $rvm_path/hooks/after_cd_bundler
</code>
为自己的项目创建bundler stubs.
<code>bash
$ cd your_project_path
$ bundle install --binstubs=./bundler_stubs
</code></p>

<p>最后重新打开terminal就可以直接执行ruby命令，不需要加上<code>bundler exec</code>前缀。</p>

<p>如果想禁用次bundler的话，只需要在命令前面加上<code>NOEXEC_DISABLE=1</code>前缀。更详细的信息可以看[rubygems-bundler]的<a href="https://github.com/mpapis/rubygems-bundler">文档</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在本地安装git的HTML帮助文档]]></title>
    <link href="http://www.huangbowen.net/blog/2012/08/08/zai-ben-di-an-zhuang-gitde-htmlbang-zhu-wen-dang/"/>
    <updated>2012-08-08T00:48:00+08:00</updated>
    <id>http://www.huangbowen.net/blog/2012/08/08/zai-ben-di-an-zhuang-gitde-htmlbang-zhu-wen-dang</id>
    <content type="html"><![CDATA[<p>当我们想查询git某条指令如何使用时，<a href="http://git-scm.com/documentation">git</a>官网有详尽的文档供我们查看。在命令行下我们也可以随时通过 git --help的方法查看某条命令的详细帮助。</p>

<p>相对于在Terminal中内置的帮助文档，HTML格式更清晰，更详尽。</p>

<p>但是如果我想在无法上网的情况下也能查看git官网的详尽的帮助文档，有没有办法那？当然有了，下面就教大家如何在本机搭建git的HTML帮助文档。</p>

<p>在Windows上设置很简单，主需要安装<a href="http://code.google.com/p/msysgit/">Msysgit</a>,就会自动为你设置起本地的HTML帮助文档。所以这篇文章主要讲在Mac和Linux下该如何实现。</p>

<p><strong>一，运行git help –-web commit查看git默认的保存html文件的路径。</strong></p>

<p>```bash
$ git help --web commit</p>

<h1>Attempt to open the html help for the commit command</h1>

<h1>fatal: '/usr/local/git/share/doc/git-doc': not a documentationdirectory.</h1>

<p>```</p>

<p>我们得到了git默认的存放html文件的路径是<code>/usr/local/git/share/doc/git-doc</code>。当然你得到的路径有可能和这个不一样。</p>

<p><strong>二，切换到这个路径下，迁出存放在git repo中的html文件。</strong></p>

<p>```bash
$ sudo mkdir -p /usr/local/git/share/doc</p>

<h1>Create the path for the docs to be installed to cd #/usr/local/git/share/doc</h1>

<p>$ sudo git clone git://git.kernel.org/pub/scm/git/git-htmldocs.git git-doc</p>

<h1>Clone the git repo and check out the html documents branch</h1>

<p>```</p>

<p><strong>三，运行 vim ~/.gitconfig 命令，在.gitconfig文件中加入如下配置。</strong></p>

<p>```xml
[help]</p>

<pre><code>    format = web
</code></pre>

<p>[web]</p>

<pre><code>    browser = open
</code></pre>

<p>```</p>

<p>当然也可以使用其他的编辑器来编辑.gitconfig文件。</p>

<p>只要这三步就设置起了本地的HTML帮助文档。你可以再次运行<code>git help -–web commit</code>，就可以查看在浏览器中自动打开的HTML帮助说明页面了。</p>

<p>如果git的帮助文档更新了，如何同步到本地那？很简单，运行<code>git pull</code>命令就行。</p>

<p><code>bash
$ cd /usr/local/git/share/doc/git-doc
$ sudo git pull
</code></p>

<p>如何查看这些帮助文档那？更简单了，例如：</p>

<p><code>bash
$ git remote --help
</code></p>

<p>就会自动在浏览器中打开针对remote的帮助文档。</p>
]]></content>
  </entry>
  
</feed>
