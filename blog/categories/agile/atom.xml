<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Agile | 黄博文的地盘]]></title>
  <link href="http://www.huangbowen.net/blog/categories/agile/atom.xml" rel="self"/>
  <link href="http://www.huangbowen.net/"/>
  <updated>2013-08-25T12:28:28+08:00</updated>
  <id>http://www.huangbowen.net/</id>
  <author>
    <name><![CDATA[黄博文]]></name>
    <email><![CDATA[huangbowen521@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何让站会变得高效]]></title>
    <link href="http://www.huangbowen.net/blog/2013/08/06/effective-standup-meetings/"/>
    <updated>2013-08-06T06:38:00+08:00</updated>
    <id>http://www.huangbowen.net/blog/2013/08/06/effective-standup-meetings</id>
    <content type="html"><![CDATA[<p><img src="/images/standup.jpeg"></p>

<p>Stand up meeting作为敏捷项目开发中的一个重要实践不可或缺。站立会议每天都要发生，在会议上大家可以了解到每个人的工作进展、项目遇到的concern和issue，从而做出适应的资源调整和措施，保证项目交付的顺利进行。如何让站会变得高效，本人总结了一些tips，希望对大家有用。</p>

<!-- more -->


<h2>站会的形式</h2>

<p>一般站会分为两个形式。一种是在站会上每人轮流进行各自的状态更新，另一种是以story wall上的user story为主进行更新。
第一种好处是每人都有更新机会，但是更新的内容稍显混乱，第二种好处是通过卡片追踪能更清晰的了解到当前的状态，不好的地方是如果有人的工作任务没体现在卡片上，可能就没机会得到更新。</p>

<p>我个人比较倾向于第二种更新方式。一个典型的story wall有这些列: BACKLOG->BA->DEV->TEST->UAT->DONE。站会开始的时候，由一个facilitator按照从DONE->UAT->TEST->DEV->BA的顺序依次念出这些故事卡，被点到的故事卡则由工作在这张卡上的人进行相应的更新。之所以采用倒序是出于精益的思想。我 们敏捷的迭代式开发就是要将story card尽量的往done column里挪，采用倒序过卡的方式就是要突出这一点。当将墙上所有的卡都过完后，facilitator可以再问下有没有其他人有update，这样可以防止有些人由于工作不能体现在卡片上而漏掉更新。比如迭代经理可以此时做出自己的更新。最后facilitator再问还有什么问题或风险没，此时可以把自己的一些想法表露给团队,好借团队之力拿出应对方案。</p>

<h2>个人的更新</h2>

<p>个人的更新注重言简意赅，突出重点。一般更新需要包括下面三点。</p>

<ol>
<li><p>昨天做了什么。这个只需2句话带过，切忌陷入细节。</p></li>
<li><p>有没有遇到问题，需不需要资源或帮助。如果遇到什么困难，可以大概描述下，并指出需要什么样的帮助。</p></li>
<li><p>今天打算做什么。</p></li>
</ol>


<h2>一些tips</h2>

<ol>
<li><p>站会一定要站着开。凡是坐着的会议都短不了。</p></li>
<li><p>one conversation. 站会上的时候一定要保证同一时刻只有一个人说话，切忌变成了群体讨论。做法可以是将一个小玩具作为token，只有拿着这个token的人才可以说话。</p></li>
<li><p>限制每个人更新的时间。有些人在更新自己工作状态的时候喜欢讲的很细节，无形中浪费了很多时间。这时候facilitator就需要适时的打断他，可以告诉他只要给出大概的内容进行，细节部分可以会后再讨论。</p></li>
<li><p>团队中成员轮流当facilitator。一般团队中喜欢固定一个人当facilitator，一当就当到了项目结束。其实更好的做法是每天站会时都要更换facilitator，这样保证每个人都能充分参与到团队中。</p></li>
<li><p>站会不能迟到，也不要定在刚上班时。刚踩着点进办公室就迎来站会略显紧张，很多人还没调整好状态。
一般可以将站会定为早上上班15分钟后。</p></li>
<li><p>凡是可能花时间的讨论都不要发生在站会上。站会只是专注状态更新，暴露问题，而不是解决问题。针对会上暴露的问题可以再组织相关的人商讨解决方案。</p></li>
<li><p>切忌将站会流于形式，失去原有的意义。站会注重的是team间横向的沟通，并且每天都会发生，如果不能坚持就说明了团队间配合出现了问题，失去了快速反馈的意义。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[持续集成之道：在你的开源项目中使用Travis CI]]></title>
    <link href="http://www.huangbowen.net/blog/2013/05/30/use-travis-ci-to-your-open-source-project/"/>
    <updated>2013-05-30T14:58:00+08:00</updated>
    <id>http://www.huangbowen.net/blog/2013/05/30/use-travis-ci-to-your-open-source-project</id>
    <content type="html"><![CDATA[<p>自从接触并践行了敏捷的一些实践之后，便深深的喜欢上了敏捷。尤其是测试自动化和持续集成这两个实践，可以显著的提高软件的质量和集成效率，实时检测项目健康度，使团队成员对项目保持充足的信心。</p>

<p>但是对于个人项目而言，虽然测试自动化好实现，但是要实现持续集成还是稍有难度。因为持续集成需要搭建一个集成服务器，并建立某种反馈机制。而大多数人来说并没有自己的独立服务器，并且配置也极为繁琐。</p>

<!-- more -->


<p>不过不用怕，现在已经进入了云时代。 <a href="(https://travis-ci.org/)">Travis CI</a>为我们提供了免费的集成服务器，让我们省却了自己搭建集成服务器的烦恼。</p>

<p><a href="(https://travis-ci.org/)">Travis CI</a>的官网介绍是: <strong>A hosted continuous integration service for the open source community.</strong> 表明它主要是给开源社区提供持续集成服务。其与github这个全球最火爆的代码托管网站高度集成，可以很方便的为github中的项目建立持续集成服务。</p>

<p>它不仅支持多种语言，而且支持同时在多个运行环境中运行build，能全方位的测试你的程序。</p>

<p>下面就介绍下如何将<a href="(https://travis-ci.org/)">Travis CI</a>与自己在github上的某个repository集成。（这里以我自己的repository <a href="https://github.com/huangbowen521/SpringMessageSpike">https://github.com/huangbowen521/SpringMessageSpike</a> 为例。 ）</p>

<ol>
<li><p>使Travis CI通过github OAuth认证。</p>

<p> 点击<a href="https://travis-ci.org/">https://travis-ci.org/</a>右上角的<code>Sign in with GitHub</code>按钮，输入自己的github账号和密码，并允许Travis CI的认证。</p></li>
<li><p>激活GitHub Service Hook。</p>

<p> GitHub给用户提供了一个Service Hook接口,只要用户对host在github上的repository作用了一些action(比如push，pull)，就会触发相应的Service Hook。而<a href="(https://travis-ci.org/)">Travis CI</a>正是基于这个原理来trigger你的build。当你发起一个push操作时，就会trigger <a href="(https://travis-ci.org/)">Travis CI</a>的服务。</p>

<p> 设置方法是访问<a href="(https://travis-ci.org/)">Travis CI</a>的<a href="https://travis-ci.org/profile">profile</a>，选择相应的repository打开Service Hook开关。</p>

<p> <img src="/images/TravisProfile.png"></p>

<p> 然后登陆你的github，访问具体的repository的Service Hook页面，确保设置了Travis CI Hook的github name和travis token。</p>

<p> <img src="/images/ServiceHook.png"></p></li>
<li><p>给repository配置.travis.yml文件。该文件需要放置在repository的根目录下。</p>

<p> .travis.yml文件是一个相当重要的文件，里面需要配置你所使用的语言、运行环境、构建工具、构建脚本、通知方式等。最重要的是设置语言，其它的都有相应的默认值。</p>

<p> 这是为我的<a href="(https://github.com/huangbowen521/SpringMessageSpike)">SpringMessageSpike</a>设置的.travis.yml文件。由于我的项目中使用了maven作为构建工具，而<a href="(https://travis-ci.org/)">Travis CI</a>对java语言设置的默认构建工具就是maven，所以无需在文件中显式指定。</p></li>
</ol>


<p>```yaml .travis.yml</p>

<p>language: java
jdk:
  - oraclejdk7
  - openjdk7
  - openjdk6</p>

<p>```</p>

<p>你可以使用一个travis-lint来检查你的yml文件是否是有效的。他是ruby写的一个gem，需要ruby的运行环境。安装方式是在terminal下<code>gem install travis-lint</code>。你只需要在你的repository根目录下运行<code>travis-lint</code>即可进行检查。</p>

<p>想要更进一步的关于.travis.yml的配置请参见：<a href="http://about.travis-ci.org/docs/user/build-configuration/">http://about.travis-ci.org/docs/user/build-configuration/</a></p>

<p>只要这三步就完成了配置。现在发起一个push就可以trigger你在<a href="(https://travis-ci.org/)">Travis CI</a>的build。
这时候登陆<a href="(https://travis-ci.org/)">Travis CI</a>可以看到你的Build的状态和日志。</p>

<p><img src="/images/BuildInfo.png"></p>

<p>你可以在respository的README.md文件中加入build状态图标。方法是在在该文件中加入
<code>[![Build Status](https://travis-ci.org/[YOUR_GITHUB_USERNAME]/[YOUR_PROJECT_NAME].png)](https://travis-ci.org/[YOUR_GITHUB_USERNAME]/[YOUR_PROJECT_NAME])</code>即可。</p>

<p><img src="/images/BuildImage.png"></p>

<p>总体来说<a href="(https://travis-ci.org/)">Travis CI</a>是一个轻量级、可高度定制化的免费的持续集成服务。但我觉得还是有几个缺点:</p>

<ol>
<li><p>运行build需要大量的准备，耗时较长。</p></li>
<li><p>作为免费的服务，不支持build时间超过20分钟的项目。</p></li>
<li><p>主站访问速度略慢。</p></li>
</ol>

]]></content>
  </entry>
  
</feed>
