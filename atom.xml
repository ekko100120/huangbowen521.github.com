<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[黄博文的地盘]]></title>
  <link href="http://www.huangbowen.net/atom.xml" rel="self"/>
  <link href="http://www.huangbowen.net/"/>
  <updated>2016-01-04T02:02:20+08:00</updated>
  <id>http://www.huangbowen.net/</id>
  <author>
    <name><![CDATA[黄博文]]></name>
    <email><![CDATA[huangbowen521@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[膝盖中了一箭之康复篇-第六个月]]></title>
    <link href="http://www.huangbowen.net/blog/2016/01/04/acl-recovery-for-6th-month/"/>
    <updated>2016-01-04T00:27:03+08:00</updated>
    <id>http://www.huangbowen.net/blog/2016/01/04/acl-recovery-for-6th-month</id>
    <content type="html"><![CDATA[<p>时间过的很快，已经术后半年了。</p>

<!-- more -->


<p>12月份照样出差，不过地点比较固定，就呆在深圳。之前9月份的时候曾经在深圳这边的健身房练过一段时间，所以这次酒店还选择的是上次那家，就为了能在健身房好好恢复一下腿部肌肉。但是不巧的是我去过的那家健身房关门了，不得已找了一家远一点的。</p>

<p>就这样开始了力量训练，一周能去个3到4次。已经有好几个月没做力量训练了，再加上有氧运动做多了，肌肉退化的厉害。卧推以前一边15公斤杠铃能轻松推个3组。现在发现只能推一组就累的不要不要的。其它部分的肌肉也变弱了，尤其是腹肌，坐30个仰卧起坐都要慢慢来。哎，从头练起吧。扔了好久的腹肌撕裂者又开始练了。好在经过这一个月的腹肌特训，腹肌耐力有了明显的提高。</p>

<p>这段时间减肥到了瓶颈期，体重保持在71公斤左右，怎么也下不了70公斤。每天晚上除了和同事有饭局外，其它时间自己都不吃晚饭，就吃点水果，运动完吃10个考生蚝，但是体重就是纹丝不动。这是一场攻坚战。去年为了体重下70公斤，那个月我练的非常苦的。现在吃不了那么多苦，但可以把时间拉长，反正我不着急，离夏天还远着那。</p>

<p>跑步训练也在继续。这个月跑了三场线上半程马拉松，其中两场是背靠背，状态不错。但唯一报名的一场线下马拉松-新川杯慈善马拉松在开跑前一周竟然宣布取消了，太坑爹了。我的报名费都交了，你们也太不靠谱了。12月份共跑步14次，总跑量177公里。其中有一次是越野跑训练，五上五下黄金山，海拔爬升200米。对！黄金山就是个海拔落差40米的小土包子。</p>

<p>本来计划是术后半年挑战一次全马的，照现在恢复的情况来看全马肯定是没有问题的。只不过还没找到一个合适的比赛去达成。全马不像半马。半马我可以不带任何补给就能完成。全马还是需要带补给的，而且4个多小时好无聊，没人陪很难熬得下来。</p>

<p>我在11月的时候拍了核磁共振的片子，但一直没时间拿给主治医生看。我得抽个时间去和主治医生见上一面，就等他批准我可以进行对抗运动了。已经1年没有打球、踢球了，我都忘记了那种感觉了。是时候把这种感觉找回来了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[博客即代码]]></title>
    <link href="http://www.huangbowen.net/blog/2015/12/08/bloging-as-code/"/>
    <updated>2015-12-08T01:59:35+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/12/08/bloging-as-code</id>
    <content type="html"><![CDATA[<p>之前我写过一篇博客，<a href="http://www.huangbowen.net/blog/2013/04/01/min-jie-de-xie-bo-ke/">敏捷的写博客</a>，借鉴了敏捷看板的思想来管理博客。</p>

<!-- more -->


<p>而在DevOps领域有一个很火的技术实践叫做基础设施即代码。Kief对基础设施即代码的解释是这样子的：</p>

<blockquote><p>基础设施即代码是一种使用新的技术来构建和管理动态基础设施的方式。它把基础设施、工具和服务以及对基础设施的管理本身作为一个软件系统，采纳<strong>软件工程实践</strong>以结构化的安全的方式来管理对系统的变更。</p></blockquote>

<p>里面的关键一点是以<strong>软件工程实践</strong>的方式来管理基础设施。那么对于我们的博客可不可以也采纳软件工程实践的方式来管理那？答案是可行的。</p>

<ol>
<li><p>选取合适的<strong>语法</strong></p>

<p> 既然想写代码一样写博客，那么首先要选择一种语法了，这种语法就是<a href="(https://en.wikipedia.org/wiki/Markdown)">Markdown</a>。<a href="(https://en.wikipedia.org/wiki/Markdown)">Markdown</a>非常容易上手，包含的tag刚刚够用，尤其展示代码非常方便，自从用了它再也不用和烦人的CSS打交道了。人们不仅用<a href="(https://en.wikipedia.org/wiki/Markdown)">Markdown</a>在stackoverflow上发问题、解答问题，还在GITHUB上track issue，甚至现在写邮件也用<a href="(https://en.wikipedia.org/wiki/Markdown)">Markdown</a>了。拿它来写技术文章简直不用太爽。</p></li>
<li><p>选取合适的<strong>框架</strong></p>

<p> 实现基础设施代码需要选择一款基础设施自动化工具，这些工具的特点是全命令行操作，很容易实现自动化。那么建立自己的技术博客站点也需要选择一个博客框架，支持全命令行操作的博客框架有<a href="https://jekyllrb.com/">Jekyll</a>、<a href="http://octopress.org/">Octopress</a>、<a href="https://hexo.io/">Hexo</a>等。它们各自的特点不在本文的讨论范围。但我多说一句，我现在使用的是Octopress，我也用过Hexo，我更喜欢Hexo，原因有二，一是速度快，二是环境简单。</p></li>
<li><p>选取顺手的<strong>编辑器</strong></p>

<p> 这些博客框架的特点是可以Offline写作，然后一键发布。所以你可以选用任何你喜欢的编辑器来写文章，不用使用在线编辑器和各种样式问题、网络问题抗争了。Atom、Sublime或者专业编辑工具MacDown、Mou等都行。</p></li>
<li><p><strong>一切纳入版本管理</strong></p>

<p> 这些博客框架创建博客、生成博客、发布博客全部可以命令行操作。而且所有的配置（包括对站点的基本配置、插件的配置、主题的配置）都可以直接修改配置文本，博客也是以MarkDown的格式存储，所以整个站点都可以存放在GIT之类的版本控制库中。比如我的整站博客源码都放置在<a href="https://github.com/huangbowen521/huangbowen521.github.com/commits?author=huangbowen521">GitHub</a>上，从此再也不用更担心博客内容丢失了。</p></li>
<li><p><strong>灵活的发布策略</strong></p>

<p> 它们通过命令可以生成纯静态的博客，所以无需任何web服务器都可以运行。你可以将其放置到<a href="https://pages.github.com/">GitHub Pages</a>上，或者<a href="https://www.heroku.com/">Heroku</a>上都行，或者自己随便找台免费的云主机装个nignx即可。当然也有更高大上的做法，我把整个博客放置在AWS的S3上。S3是亚马逊推出的对象存储服务，并且我还是用了亚马逊提供的全球CDN加速功能CloudFront，对我的博客进行了全球CDN加速。无论是澳洲海边还是中国内陆，访问速度都是杠杠的。</p></li>
<li><p><strong>定制开发的能力</strong></p>

<p> 漂亮的主题风格也是选取一个博客框架需要考虑的一个因素。想要更换皮肤就太简单了，也是全命令行操作。拿Octopress举例，网上有很多热心用户制作的皮肤，都托管在github上，相中以后直接通过命令行操作就可以给你的博客换上最In的皮肤。</p>

<p> 另外还有对博客的定制化也是我们关心的。每款博客框架都有丰富的插件，这些插件的代码都放置在GitHub上，完全开源，安装配置插件也非常简单，命令行全部搞定。我自己也写了一些定制化的插件，比如当我发布一个新博客的时候，只需<code>rake deploy</code>一条命令就可以把我的博客推送到我的weibo和linkedin上，也可以把整个博客内容同步到我在博客园的<a href="http://www.cnblogs.com/huang0925/">博客站点</a>上。这些插件也开源在GitHub上，分别是<a href="https://github.com/huangbowen521/octopress-linkedin">octopress-linkedin</a>和<a href="https://github.com/huangbowen521/octopress-syncPost">octopress-syncPost</a>。</p></li>
</ol>


<hr />

<p>这样子，写博客变成了一种享受。进入咨询团队以后，坚持写博客也带来了其它一些好处。比如和客户讨论一个问题时，直接把我文章链接发给他说，说这个东西我之前专门写过博客，你看了就懂了。这样瞬间在客户面前树立了专业的形象。更有甚者，客户当着我的面搜索某个技术名词，第一页第一条赫然就是我写的博客。所以可以少费些口舌，把精力用到其它地方去。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[膝盖中了一箭之康复篇-第五个月]]></title>
    <link href="http://www.huangbowen.net/blog/2015/12/01/recovery-after-acl-5th-month/"/>
    <updated>2015-12-01T17:23:25+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/12/01/recovery-after-acl-5th-month</id>
    <content type="html"><![CDATA[<p>7月1日的右膝前叉韧带重建手术，到现在已经术后满5个月了。</p>

<!-- more -->


<p>11月份跌跌撞撞就这样过去了。11月10日去主治医生那里做了复查。高医生查体以后说我恢复的相当不错，并让我再做一次MRI看看结果如何。高医生同时严重警告我在未满6个月前严谨任何剧烈运动，他说一般像我这样恢复比较好的早都蠢蠢欲动想去打球、踢球，而韧带在4-6个月的时候是非常危险的。</p>

<p>在四川省骨科医院做MRI每次都要排很长时间，我下午就又要去出差，就预约了21日做MRI。21日凌晨才从上海回来，早上6点多就爬起来去医院做MRI。拿到结果看了一下感觉结论还是比较乐观的，不过要让高医生看过片子才知道具体怎么样。TMD又要预约，每次高医生只有周二才坐诊，预约基本上要提前一周。</p>

<p>整个11月份腿部感觉良好，但是还有好几个问题。一是伤腿肌肉力量与好腿仍然不均衡，导致运动发力时不平均，运动时间长了以后两个腿的感觉是不一样的；二是伤腿仍然无法完全过伸，和好腿保持一样的完全角度；三是山地跑步训练时仍然无法完全放开，伤腿总是小心翼翼，而且还有不适感（所以至今未开展任何越野跑训练）。</p>

<p>整个11月份大部分时间在上海，在成都和武汉也呆了几天。由于到处漂泊，所以也没找一个健身房锻炼。只能偶尔到附近学校拉拉单双杠了。正手引体现在一组可以做6个了。</p>

<p>11月8日参加了上海线上马拉松活动，在锦城湖公园跑了一个半马。平均配速为6分，跑完除了肌肉有些酸痛外，膝盖没有明显不适。自3月多的重庆马拉松后又收获了马拉松完赛奖牌一只。</p>

<p>以下是11月份的训练情况。</p>

<p>11月1日跑步10公里；
11月3日跑步10公里；
11月5日跑步10公里；
11月8日跑步22公里；
11月10日跑步10公里；
11月11日跑步10公里；
11月13日跑步10公里；
11月14日跑步10公里；
11月15日跑步10公里；
11月16日跑步10公里；
11月21日跑步3公里；
11月22日跑步10公里；
11月25日跑步10公里；
11月26日跑步12公里；
11月27日跑步12公里；
11月29日跑步12公里；
11月30日跑步12公里。</p>

<p>整个11月份总共跑了180多公里。但是这180多公里基本上都是堆量，每次都是以比较舒服的节奏在跑，很少push自己。如果仅以完赛100公里越野跑为目标，我认为速度现在不是重点，重点是把耐力以及坡度训练提上日程。另外越野跑需要的肌肉群较多，所以还是要注重其它肌肉群的锻炼，尤其是腹肌。好在我整个12月份很有可能就呆在深圳，所以可以就近找一个健身房开展力量训练。有了力量训练以后可能跑步时间就要相应的减少。</p>

<p>12月份也报名了两场马拉松活动。一个是12月6日的广州线上马拉松，一个是12月19日的成都慈善马拉松。距离都是半程，也就是21公里。现在对于跑全程还是底气不足。</p>

<p>再过一个月术后就要满半年了。希望能让伤腿早日彻底康复，最好能赶得上明年4月份的大连100。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学习Scala第一篇-从hello World开始]]></title>
    <link href="http://www.huangbowen.net/blog/2015/11/15/hello-world-in-scala/"/>
    <updated>2015-11-15T01:41:24+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/11/15/hello-world-in-scala</id>
    <content type="html"><![CDATA[<p>最近开始系统性的学习scala。其实之前使用过scala的，比如我在用Gatling这款性能测试工具的时候就接触到了scala了。Gatling本身就是用Scala写的，而且Gatling的性能测试配置文件本身就是一个scala类，可以随意使用scala甚至是Java提供的各种类库。当时觉得用Gatling特别舒服的原因就在于配置文件强大的表现力。而这种表现力就是由Scala语言提供的。</p>

<!-- more -->


<p>言归正传，学习Scala还是从最简单的Hello world开始。在Scala官网中显著的标题就是：</p>

<blockquote><blockquote><p>Object-Oriented Meets Functional</p>

<p>Have the best of both worlds. Construct elegant class hierarchies for maximum code reuse and extensibility, implement their behavior using higher-order functions. Or anything in-between.</p></blockquote></blockquote>

<p>从中可以看出Scala结合了面向对象及函数式编程这两种编程范式。在本文中我将会拿Java语言和其比较，看看到底Scala强在那里。</p>

<p>使用Java语言实现一个Hello World的代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Hello World!&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>以下是Scala的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">object</span> <span class="nc">HelloWorld</span>  <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">println</span><span class="o">(</span><span class="s">&quot;Hello, World!&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>好吧，如果标点符号不算代码行，Java版本和Scala版本的实现的代码行数是一致的。貌似Scala并没有减少什么。唯一减少的就在于println不用指定类名，以及对main方法不用声明为static。</p>

<p>在这里对Scala实现与Java实现的几个不同之处做个介绍。</p>

<ul>
<li><p>第一是Scala对HelloWorld的修饰符使用的是object。其实Scala中也有class关键字，那么object关键字和class关键字有什么区别那？简单来说object关键字定义了一个匿名类，并且创建了该匿名类的单个实例（采用单例模式），该实例名为HelloWorld。所以object中定义的方法自动都是static的。我觉得object关键字存在的价值之一就是建立起了面向对象和函数式的桥梁。因为在面向对象的系统中，所有方法都必须存在于类中，而函数式编程中没有类的概念，使用函数无需new类的实例，所以object中的方法都是静态方法，可以直接被调用。进一步解读请到<a href="http://stackoverflow.com/questions/1755345/difference-between-object-and-class-in-scala">这里</a>。</p></li>
<li><p>第二是Scala中对变量的类型的定义方式是变量名在前，类型在后，中间用冒号相隔。原因之一是代码更可读。因为我们更关心变量名，而类型其次，尤其是你拥有一个超级长的类型的情况下（比如
HashMap&lt;Shape, Pair&lt;String, String>>)；原因之二据说是这样的方式在实现Scala类型时技术上要简单些。进一步解读请到<a href="http://stackoverflow.com/questions/6085576/why-does-scala-choose-to-have-the-types-after-the-variable-names">这里</a>。</p></li>
<li><p>第三是main函数的返回值是Unit，而不是Java中的Void。为什么是这样那？我想是因为Scala为了实现自己的类型系统，对于无显式返回值的函数直接使用Void是不合适的。在<a href="http://www.scala-lang.org/api/current/index.html#scala.Unit">Scala.Unit文档</a>中是这样定义Unit的：</p></li>
</ul>


<blockquote><blockquote><p>Unit is a subtype of scala.AnyVal. There is only one value of type Unit, (), and it is not represented by any object in the underlying runtime system. A method with return type Unit is analogous to a Java method which is declared void.</p></blockquote></blockquote>

<ul>
<li>第四是Scala中表达式最后的分号是可选的。原因就是为了契合函数式编程的哲学，即一切尽可能的简单。不写分号程序员一天可以多敲一些代码出来。</li>
</ul>


<p>好吧，其实在Scala中Hello World还有一种写法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">object</span> <span class="nc">HelloWordV2</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Hello, World!&quot;</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码从三行减少到了两行，Scala终于胜出了。那么App是个什么鬼？<a href="https://github.com/scala/scala/blob/v2.11.7/src/library/scala/App.scala#L1">App</a>是一个trait。trait又是什么鬼？<a href="http://docs.scala-lang.org/tutorials/tour/traits.html">trait</a>是Scala中的一个特殊类型，它与Java中的interface很相似，但比interface强大。HelloWordV2添加了对App的扩展后，就自动成为了一个可以运行的程序，由于App中定义了main方法，所以HelloWorldV2中就无需再定义了，牛逼的地方在于HelloWorldV2的body中的代码都会作为main方法中的代码被执行。以下是App源码中对main方法的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="nd">@deprecatedOverriding</span><span class="o">(</span><span class="s">&quot;main should not be overridden&quot;</span><span class="o">,</span> <span class="s">&quot;2.11.0&quot;</span><span class="o">)</span>
</span><span class='line'><span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'><span class="k">this</span><span class="o">.</span><span class="nc">_args</span> <span class="k">=</span> <span class="n">args</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="o">(</span><span class="n">proc</span> <span class="k">&lt;-</span> <span class="n">initCode</span><span class="o">)</span> <span class="n">proc</span><span class="o">()</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">util</span><span class="o">.</span><span class="nc">Properties</span><span class="o">.</span><span class="n">propIsSet</span><span class="o">(</span><span class="s">&quot;scala.time&quot;</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="n">total</span> <span class="k">=</span> <span class="n">currentTime</span> <span class="o">-</span> <span class="n">executionStart</span>
</span><span class='line'>
</span><span class='line'><span class="nc">Console</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">&quot;[total &quot;</span> <span class="o">+</span> <span class="n">total</span> <span class="o">+</span> <span class="s">&quot;ms]&quot;</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>看来App在实现main方法时还设置了一个计时器，通过scala.time这个属性来开关。所以没事翻翻源码还是挺好玩的。</p>

<p>不知有没注意到其实main方法是有个叫args的参数的，那么新版HelloWorld中如何使用该参数那？直接使用它就行。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">object</span> <span class="nc">HelloWordV2</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">println</span><span class="o">(</span><span class="s">&quot;Hello, World!&quot;</span> <span class="o">+</span> <span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>ok，Scala版的Hello World就到这里吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在ThoughtWorks工作这几年我学到了什么？]]></title>
    <link href="http://www.huangbowen.net/blog/2015/11/11/what-i-learn-in-thoughtworks/"/>
    <updated>2015-11-11T00:24:39+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/11/11/what-i-learn-in-thoughtworks</id>
    <content type="html"><![CDATA[<p>不知不觉，从2012年5月1日加入ThoughtWorks到现在，已经3年有余了。时间过得很快，这三年多我干了很多事情，但仔细想想也没有什么特别值得一提的。在一个公司呆久了总觉得很多事情是理所当然的，直到今年进入了咨询团队，走马观花般见识了很多其他公司的团队和项目，才发现在ThoughtWorks的准则和其它公司的玩法是完全不同的。</p>

<!-- more -->


<p>仔细想想，在ThoughtWorks给我带来了那些东西那？</p>

<ol>
<li><p>英语的提升。遥想加入ThoughtWorks之前，在前公司打算跳槽的时候，专门花了很长时间来学习英语，因为那时候我知道搞IT这行英文好就可以如虎添翼。但由于英文丢的太久了，词汇量不到500，发音更是全忘光了。到了ThoughtWorks后又要练英语，又要学技术，压力山大。不过挺过去以后就好了。这几年来不知不觉翻译了3本书（第4本进行中），和无数篇文章；也在海外工作过半年；平时看的各种英文资料更是不计其数。当你把英文真正作为获取知识的工具时，你会发现英文一点也不讨厌，它能让你瞬间拉开与他人的差距。</p></li>
<li><p>敢于走出舒适区。我喜欢一句话，稳定不是在一个公司一呆就是10年，而是今天辞职明天就能找到工作。这句话的霸气在于你要时刻保持一种警惕，不要随波逐流。过安逸的生活是人的本性，而这种生活会让你逐渐丧失竞争力。所以我们不仅敢于变化，还要主动求变，走出舒适区，进入学习区，甚至恐慌区，锤炼自己，把自己的知识区扩大。</p></li>
<li><p>坚持，水滴石穿。严格来说这点不算是ThoughtWorks带给我的，不过我在ThoughtWorks里得到了良好的贯彻。我最早开博是在2008年，后来断断续续一直在写，但后来由于各种原因中断了很久。2012年重新开博以后，基本上每月都有几篇，现在累计了100多篇。不说大话，定目标，然后一步一步向目标前进，这种方式不仅可以用在工作中，也可以用在生活中。但凡有了这种坚持的精神，那么干什么事情都不怕半途而废。</p></li>
<li><p>高效的学习方式。IT这个行业基本上是知识爆炸的行业，每天都有大量的信息涌出。而个人的精力是有限的，知识是无限的。所以在学习的时候要有所取舍，既要广也要精。而据我观察大多数人都是既没有做到广，也没有做到精。很多人学习方式、学习态度都是有问题的，而在ThoughtWorks有大量优秀的人在不停的分享他们的学习方式，我也在不断的总结。正是这种专业的学习方式促使我们能高效的学习。</p></li>
<li><p>学会反思。我们拒绝做流水线上的员工，我们欢迎每个人有自己独立的思维。在思维的碰撞之中我们都在不断的前进。不能光顾着埋头犁地，我们需要时不时的停下来，休整一下，做好规划，再继续前行。</p></li>
</ol>


<p>在ThoughtWorks你很容易就能找到有想法的人，和他们聊一聊总会有所收获。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[膝盖中了一箭之康复篇第四个月]]></title>
    <link href="http://www.huangbowen.net/blog/2015/11/05/acl-recovery-for-4th-month/"/>
    <updated>2015-11-05T23:51:19+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/11/05/acl-recovery-for-4th-month</id>
    <content type="html"><![CDATA[<p>7月1日的右膝前叉韧带重建手术，到现在已经是4个月了。</p>

<!-- more -->


<p>9月底的时候情况是步态基本正常，上下楼也没问题。跑步训练一次10公里后也无异常，只是速度放的很慢。
国庆节期间去了老婆老家，那几天基本都在玩，没有进行任何恢复性的训练。由于国庆节几天的放纵，把我9月份辛苦减的脂肪全吃回来了，胖了不少。国庆后重新开始跑步训练，并且配合节食减肥。</p>

<ul>
<li>10月7日跑步10公里；</li>
<li>10月8日跑步5公里；</li>
<li>10月9日跑步14公里；</li>
<li>10月11日跑步10公里；</li>
<li>10月14日跑步5公里；</li>
<li>10月17日跑步10公里；</li>
<li>10月18日跑步10公里；</li>
<li>10月23日跑步10公里；</li>
<li>10月26日跑步10公里；</li>
<li>10月28日跑步10公里；</li>
<li>10月30日跑步5公里。</li>
</ul>


<p>整个10月份基本上都在上海出差，在酒店附近没有找到适合的健身房，但是周边有个上海市第二工业大学，所以绝大部分跑步都是在学校操场进行的，跑完以后再做做引体向上，臂屈伸。现在一次能拉6个标准的正手引体向上了，离受伤前的10个还差4个。这段时间还是专心一减脂为主，待有条件了再进行力量训练。</p>

<p>每次跑步右膝并没有太大的异常反应，跑完以后感觉还好。但是能明显感觉出来右膝盖的肌肉力量不足，对膝盖的保护不够，所以要接下来要加强右膝的肌肉锻炼，只是苦于没有条件。我更习惯使用健身房的器械进行腿部的肌肉训练，徒手无器械的方式不是很喜欢。</p>

<p>现在10公里跑的时间已经可以跑进55分钟，但是离最佳的48分钟差距还是明显。下周二预约了主治医生，对我的腿部再进行一下检查，如果检查结果良好，那么我就可以放心的继续训练了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[膝盖中了一箭之康复篇9-12周]]></title>
    <link href="http://www.huangbowen.net/blog/2015/09/30/acl-recovery-part-3/"/>
    <updated>2015-09-30T01:00:33+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/09/30/acl-recovery-part-3</id>
    <content type="html"><![CDATA[<p>2015年7月1日做的ACL手术，上一篇写到了4-8周的恢复情况，也就是8月份的恢复情况。当时情况是走路稍微有点瘸，速度和正常人无异，弯腿角度140度左右。训练情况是每周去健身房3次左右，每次椭圆机20分钟，固定自行车30分钟，另外加上一些力量训练。</p>

<!-- more -->


<p>整个8月份基本都在出差，8月底回到了成都。我预约了9月8日和主治医生的复查。8日那天早上到了医院发现门诊的人很少，所以没怎么排队。高医生给我做了一下抽屉实验，然后试了一下角度，说我恢复的很不错。我问医生可以跑步了不？高医生说可以了，我问跑多长时间，高医生说以不痛不肿为主。整个复查过程不超过5分钟，感觉有些坑爹。可能高医生认为我恢复的不错，所以没有多问。</p>

<p>刚复查完就接到出差通知，于是9号就飞到了深圳。到了深圳的当晚在酒店附近找到了一个很小的公园，开始了我术后第一次跑步训练。我围着广场跑了5公里，耗时42分钟，非常慢的配速。整个过程感觉还好，右腿膝盖没有明显不适，膝盖也没有变肿。自从4月份败走大连后，这还是第一次跑步训练，时间跨越了5个月之久。长时间的不训练+伤病使我的身体素质大大下降，跑步的感觉也全无。</p>

<p>9月中旬在新的酒店附近找到了一家健身房，可以团购按次数记的体验卷，10块钱一次。整个健身房条件一般，不过对于我来说够用了，唯一缺少的设备就是椭圆机，好在几个练腿的设备都有。我把训练调整为跑步30分钟，曲申膝器械4*20组，然后再辅助一些上肢力量训练，把力量再练回来。去年9月的时候是我身材的巅峰，体重为68公斤，体脂比13.8，引体向上可以拉10个。而一年后被打回原形，体重暴增至73公斤，引体向上一度一个都做不了。至少要花半年才能再回去年的巅峰，哎。</p>

<p><img src="http://www.huangbowen.net/images/thumb_IMG_2440_1024.jpg" width="300"></p>

<p>跑完第二天膝盖感觉还好，跟平时一样。这说明我可以逐步恢复跑步训练了，又要减脂了。之后每隔一两天就去跑一次，每次都在30分钟多点，距离是3公里多。跑完以后拉伸一下，做几个引体向上，臂屈伸。这样终于找回了点以前运动的感觉。</p>

<p>9月20日去了南京出差，21日晚上坐地铁夜游玄武湖，发现这是个跑步的好地方，所以一口气就跑了15公里，耗时将近2小时。跑的整个过程中节奏把握的比较好，速度控制的很慢，所以身体没有明显的不适。跑完以后感觉也比较好，第二天也没觉得累，看来身体底子还在。</p>

<p><img src="http://www.huangbowen.net/images/xuanwuhu_run.jpg" width="300"></p>

<p>9月22日晚上又飞回深圳。我在健身房花50团购卷买了张周卡，基本每天下班就去健身房。虽然白天在客户现场压力很大，下班后事情也是多的很，但健身也可以算是减压的一种。基本也恢复了每天练一个大块集群的节奏，而腿部锻炼则天天做。不过锻炼时的状态不是很好，每次都感觉没有尽全力。为了减脂，我也特意控制了饮食。每天早、中饭照常，晚饭隔一天吃一次，不吃的那天只吃点水果。</p>

<p>很快也就9月底了。目前我有个问题是伤腿过伸无法和好腿一致，所以这可能是走路还是稍微有点瘸的原因。我以前认为只要肌肉上来了，自然就过伸了，所以没有怎么专门练过过伸。不过我认为这不是个大问题。</p>

<p>接下来是继续持续性的腿部康复训练，另外把跑步训练、减脂及力量训练都再搞起来。我报名了今年广州马拉松的半马比赛，时间是11月份多，所以还要抓紧时间恢复，继续开始我的拿牌之旅。惭愧的是一直没找到一个室内游泳馆，不能进行游泳训练，铁三也无从谈起。</p>

<p>心里计划术后半年左右就开始参加全马比赛，以便赚取越野赛的参赛资格。现在跑越野右膝还是不行，希望半年后能开始越野跑训练，以便伺机找个轻松点的比赛赚取百公里越野的资格。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Chef管理windows集群]]></title>
    <link href="http://www.huangbowen.net/blog/2015/09/06/use-chef-to-manage-windows-cluster/"/>
    <updated>2015-09-06T12:06:23+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/09/06/use-chef-to-manage-windows-cluster</id>
    <content type="html"><![CDATA[<p>但凡服务器上了一定规模（百台以上），普通的ssh登录管理的模式就越来越举步维艰。试想Linux发布了一个高危漏洞的补丁，你要把手下成百上千台机器都更新该补丁，如果没有一种自动化方式，那么至少要耗上大半天时间。虽然你编写了大量的shell（或python，perl）脚本来实现各种自动化场景，但最后会发现你又陷入了脚本的汪洋大海之中，管理和维护这么多的脚本的成本也不小。你需要一款基础设施自动化工具，希望它能具有以下功能。</p>

<!-- more -->


<ol>
<li><p><strong>批量执行。</strong>这个不多说了吧，试想要为每一台机器打补丁的情形吧。</p></li>
<li><p><strong>任务编排。</strong>现在稍微复杂点的应用都需要N台服务器来部署，而部署的过程中肯定有个先后的依赖顺序。那么由此看来任务编排肯定必不可少。</p></li>
<li><p><strong>对业务场景的抽象，也就是DSL化。</strong>之所以抛弃自己用shell(或其它语言的)脚本来实现各种自动化的原因之一就是这些脚本很难懂，除了你以外其他人几乎无法修改。而作为一个成熟的工具，自然对咱们复杂的应用场景要做抽象，比如对服务器节点、角色的抽象，对服务器上的各种安装、配置操作的抽象，对不同环境的抽象等。通过抽象出来的DSL，大家很容易达成一致，协同工作。</p></li>
<li><p><strong>安全机制。</strong>既然是基础设施自动化工具，免不了包含各种敏感信息，如何去敏也是挺重要的。而且既然能控制整个服务器集群，控制方式也要绝对安全。</p></li>
</ol>


<p>除了这几个基本功能以外，当然我们还希望有更多功能，比如脚本重用、审计功能、完善的文档等。这里就不多说了。</p>

<p>类似的工具肯定已经有了，现在市场上比较流行的开源软件有Puppet、Chef、Ansible、SaltStack等。关于它们的优劣不是这篇文章的重点。</p>

<p>而谈起集群管理，大家似乎默认的都是对Linux系统集群的管理，对于Windows集群则很少涉及。我想这大抵有两方面的原因，一方面是大部分公司中机器集群类型大都是Linux系统，另一方面是Windows机器在批量化管理方面天然有缺陷，比如缺乏各种方便的脚本命令、很难对机器配置完全脚本化等。但对Windows集群的管理问题无法回避，因为在企业中Windows集群的确存在。微软也在致力改善这些问题，比如Window PowerShell就是为了解决校本化的问题。</p>

<p>而笔者的上一个项目就涉及对数百台Windows和Linux集群的管理。Windows集群的主要操作系统是Windows Server 2008，Linux集群的主要操作系统是Ubuntu 12.04。要实现对这样的集群的自动化配置和管理，笔者积累了一些经验，特意分享给大家。</p>

<h2>自动化工具的选型</h2>

<p>凡是牵扯到工具选型的时候，如果你发现你处于一个非常纠结的地位，那可能是因为竞品工具没有一个能突出重围，导致你在它们各自的优缺点之间难以取舍。我也理解，工具选型要考虑的因素太多。这个项目的选型其实没经过太大波折，很快就决定使用Chef。原因我可以简单说一下，Puppet的API太不友好，ansible和salt对windows的支持程度未知，而根据我以前的经验，Chef对windows的支持还是比较成熟的。所以我们就快刀斩乱麻选择了Chef。</p>

<h2>搭建Chef生态环境</h2>

<p>既然决定了Chef，那么接下来很多问题都不得不考虑。</p>

<h3>使用自建的Chef Server</h3>

<p>原因很简单，因为客户不会把自己的node暴露在公共的chef server之上。所以我们在企业内网搭建了一个Chef server，放置在一台ubuntu机器上。</p>

<h3>workstation选择windows机器(windows 7)</h3>

<p>考虑到我们要同时管理Linux集群和Windows集群，所以workstation的选择也很重要。在bootstrap一个node的时候，workstation和linux node的通讯方式是ssh，而和windows node的通讯方式是通过WinRM。如果使用Linux通过WinRM和Windows系统通讯，理论上是可行的，我们可以借助一些第三方工具实现，但过程肯定比较曲折。而如果使用Windows机器和Linux及Windows系统通讯，则没有太大问题。</p>

<h3>搭建自己的软件仓库</h3>

<p>对于Linux系统而言有很多成熟的包管理工具，想要安装什么软件基本上一条命令即可。而对于Windows系统而言，虽然有<a href="https://chocolatey.org/">chocolatey</a>之类的工具，但在分发一些企业内部的软件方面仍捉襟见肘。所以我们选择搭建自己的软件仓库。刚开始为了简便起见就搭建了一个ftp服务器作为软件仓库。后期会考虑迁移到<a href="http://www.sonatype.com/nexus/product-overview">Sonatype Nexus</a>之类能提供更多功能的包管理服务器上去。</p>

<p>创建Chef repo并纳入源代码管理之类的事情由于没有太多特殊性，所以这里就不展开了。</p>

<h2>应用Chef管理windows集群</h2>

<p>使用Chef来管理windows集群肯定没有像管理Linux集群那么容易，以下是几个需要注意的点。</p>

<h3>配置Windows node开启WinRM服务</h3>

<p>WinRM服务是微软提供的用于进行远程通讯的服务（Windows 7及以后的系统内置支持），你可以简单理解为Windows版的SSH。在Windows server 2008 R2操作系统中，WinRM服务默认是关闭的，我们需要启用它。首先需要修改两个组策略。在组策略的计算机配置->策略->Windows组件->Windows远程管理(WinRM)->WinRM服务中，选择“允许自动配置监听器”，把该策略选为启用，并修改IPv4和IPv6过滤器为*。然后在控制面板中选择windows防火墙，单击例外选项卡，选择Windows 远程管理复选框。如果看不到该复选框，请单击添加程序以添加 Windows 远程管理。
（具体请参见<a href="http://www.briantist.com/how-to/powershell-remoting-group-policy/">http://www.briantist.com/how-to/powershell-remoting-group-policy/</a>）</p>

<p>这两项的配置也可以通过PowerShell脚本来实现。想要了解的可以参见这篇文章<a href="https://powertoe.wordpress.com/2011/05/16/enable-winrm-with-group-policy-but-use-powershell-to-create-the-policy/">https://powertoe.wordpress.com/2011/05/16/enable-winrm-with-group-policy-but-use-powershell-to-create-the-policy/</a>。</p>

<p>然后就可以启用和配置WinRM了。只需要在PowerShell终端输入<code>winrm quickconfig -q</code>即可。另外Chef还推荐对WinRM进行一些进阶配置，具体请参见<a href="https://github.com/Chef/knife-windows#requirementssetup">https://github.com/Chef/knife-windows#requirementssetup</a>。</p>

<h3>使用windows cookbook</h3>

<p><a href="https://github.com/opscode-cookbooks/windows">windows</a> cookbook是Chef专为windows平台写的cookbook。里面包含了非常多的针对windows平台特性的功能，是操纵windows平台不可或缺的利器。比如解压缩文件、执行batch(PowerShell)命令、安装认证、安装卸载windows包、配置执行计划任务&hellip;&hellip;</p>

<p>使用方式也很简单，安装可以通过chef的supermarket执行，具体参见<a href="https://supermarket.chef.io/cookbooks/windows#knife">https://supermarket.chef.io/cookbooks/windows#knife</a>。如果在其它cookbook需要使用该cookbook的模块，只需在其它cookbook的metadata.rb中加入<code>depends ‘windows’</code>即可。</p>

<h3>升级Windows node上的PowerShell版本</h3>

<p>PowerShell之于Windows就相当于shell之于Linux。Windows Server 2008 R2上的PowerShell默认版本是3.0，最好能够升级到高级版本。而<a href="https://github.com/opscode-cookbooks/powershell">https://github.com/opscode-cookbooks/powershell</a>中的cookbook则可以方便的对Windows node的PowerShell进行升级和配置,以及安装各种PowerShell module，执行PowerShell脚本等。</p>

<h3>实现对软件的静默安装</h3>

<p>Linux上的每种软件基本都有通过命令行静默安装的方式。而Windows下的软件却不尽然。如果软件是以.msi方式打包的，那么可以使用Windows Installer来实现静默安装。如果是以.exe的方式来打包的，倒也不被惊慌，可以仔细分析其是否是以inno、NSIS、installshield等方式打包的，然后根据各自方式的静默方式实现自动化安装。如果以上皆不适用，则可以分析该软件是否为绿色软件，尝试把安装后的整个文件夹打包放置于软件仓库之上，以后安装只需要解压缩即可。如果软件既没有规范的打包方式，也不是绿色软件，那么就比较麻烦了，需要分析安装后创建了那些文件，以及执行了那些脚本，然后尝试把这些操作命令行化（不过这样的软件非常少，不必过于担心）。</p>

<h3>使用push jobs功能</h3>

<p>通常我们需要对节点进行批量化操作，而通过chef-client的方式功能有限。chef提供了push jobs这样的扩展功能，允许我们对节点进行随心所欲的批量操作。详情请参见<a href="https://docs.chef.io/push_jobs.html">https://docs.chef.io/push_jobs.html</a>。</p>

<h3>熟练使用PowerShell脚本</h3>

<p>之前我说过，PowerShell在Windows上的地位就如同Shell在Linux上的地位。Windows PowerShell提供了对COM组建和WMI组件的完全访问，而且可以轻松调用.net framework框架中的功能，而且也包含强大的文档。如果你想配置一个DHCP服务器，或者配置一个IIS网站服务，抑或修改注册表，使用PowerShell能轻松让你达到目标，彻底摆脱图形化界面。</p>

<hr />

<p>总体来说，Chef对于Windows平台的支持力度还是相当完善的，如果你想实现对Windows集群的自动化管理，那么Chef不失为一种可行的方案。至于其它几种自动化工具，笔者有时间也会进行深入调研，再出具报告。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[膝盖中了一箭之康复篇4-8周]]></title>
    <link href="http://www.huangbowen.net/blog/2015/08/29/acl-surgery-recovery-phase-two/"/>
    <updated>2015-08-29T15:54:49+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/08/29/acl-surgery-recovery-phase-two</id>
    <content type="html"><![CDATA[<p>7月1日做的手术，经过一个月的康复，走路已经可以完全不用拐杖了，护具也只是在办公室的时候带着，下班回到家里一般就不带了。前4周的恢复情况请参加我前一篇文章。</p>

<!-- more -->


<p>7月29日去杭州出差，保险起见还是带了护具，装在了行李箱里。也带了一个冰袋，因为膝盖还是有些肿，希望能多冰敷消肿。（事实是直到出差结束冰袋根本没从行李箱中拿出来过）到了机场过安检好多人啊，后悔没有把护具拿出来带上，还可以走特殊通道。飞机上坐的是经济舱，右腿长期保持一个不能伸直的姿势还是有点难受，但比7月中旬的那次出差好多了。</p>

<p>到了杭州的当天晚上就刮了一阵妖风，那风刮的我路都走不动。目前膝盖虽然有点肿，但是走平路还是比较快，就是由于右腿不能过伸，有点瘸。上楼梯的时候能够交叉步，还是习惯性的要扶楼梯把手。而下楼梯的时候就不能交叉步了，只能一步一步慢慢走。来之前一直担心客户现场的厕所不是马桶的那种。来了以后发现这客户现场卫生间还是非常干净的，和我司的一样。</p>

<p>由于到了客户现场工作强度比较大，回到酒店以后比较累，渐渐就荒废了康复训练。举腿那些都好久没做了，感觉效果不大。静蹲也只试了几次。伤腿的肌肉萎缩还是非常厉害的，左腿股四头肌还能看到轮廓，右腿则什么轮廓都没有了。想当年我双腿推起160公斤杠铃无压力，还能做组，这下怕是80公斤都吃力了。掰腿的话也是想起来掰一下，没认真对待。</p>

<p>就这样随性的样子过了两周。之所以这么随性，一是因为工作忙，二是我认为健身房康复才是效果最好的。所以再术后6周的时候，我就想在周边找一个健身房，一方面开始膝盖的康复训练，另一方面也恢复我的力量训练。杭州这边的健身房好多，光我周边1公里以内的就有7，8家。但是能够提供按次付费的却不多，有的还要必须买私教。因为我在杭州的呆的时间不长，总共也就一个月左右，所以我希望能按次付费。最后终于找到一家可以办月卡的，500元一个月，健身房也比较大，有三层，分别是有氧运动区、力量训练区和恒温游泳池，而且离我住的酒店只有800米左右。这正是完全符合我理想的健身房。我立马办了一个月的，当即就开始训练了。</p>

<p>针对膝盖训练我想先从椭圆仪和固定自行车开始。椭圆仪对膝盖压力较小，能够锻炼股四头肌。我踩了20分钟依然累成狗。这就是好几个月没怎么运动的下场。固定自行车我刚开始蹬的时候伤腿还是有些不适应的，尤其是弯曲到最大的时候有些痛。不过蹬了一会就没什么大的感觉了。蹬了30分钟自行车后我又练了一会力量，就去游泳了。游泳是个非常好的运动，尤其是有关节创伤的人。因为在水中有浮力，会减轻关节的压力，而游泳消耗的也是很大的。为了不使伤腿过分运动，我泳姿采用的是仰泳。没办法，只会仰泳和蛙泳这两个姿势。有大半年没游泳了，如何踩水都给忘记了。</p>

<p>之后有断断续续去过几次健身房。每次基本上是20分钟椭圆仪、30分钟自行车，然后力量训练半小时+游泳半小时。经过这样的康复训练感觉体力逐步恢复了。这样到术后8周的时候，体重也下降了1公斤，到72公斤多了。上下楼也能交叉走了。甚至感觉我都能跑了（但是慎重起见，还是没有跑步）。角度也好久没掰了，试了一下已经能够轻松到140度了，基本没有粘连的风险了。我也没有强求角度，自角度到达了120左右以后，我认为就要加强力量训练了。只要腿部肌肉力量起来了，角度就自然起来了。</p>

<p>现在是术后8周的样子，平时走路没有任何不适，基本恢复到了正常人的水平，速度也没问题。就是稍微有点瘸，应该还是腿部没完全过伸。这个我觉得再进行一些腿部肌肉力量的训练就行。</p>

<p>接下来的目标是尽早的恢复跑步。把体重给控制下来，并且恢复力量训练，把胸肌练出来，消失的腹肌再练出来。</p>

<p>对了，术后到现在还没有找主治医生复查过，一方面是因为出差，另一方面是自己感觉恢复的还可以，没有找的必要。我想等到快3个月的时候再找主治医生复查，然后根据他的建议是否能够恢复高强度训练。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何快速掌握一门新技术/语言/框架...]]></title>
    <link href="http://www.huangbowen.net/blog/2015/08/17/learn-new-technology-quickly/"/>
    <updated>2015-08-17T09:20:36+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/08/17/learn-new-technology-quickly</id>
    <content type="html"><![CDATA[<p>IT行业中的企业特点是都属于知识密集型企业。这种企业的核心竞争力与员工的知识和技能密切相关。而如果你在企业中扮演的是工程师的角色的话，那么你的核心竞争力就是IT相关的知识与技能的储备情况。而众所周知，IT行业是一个大量产生新知识的地方，就拿Web前端举例，短短的5，6年时间，Web前端已经经历了数次变革，就目前来看变革还将继续下去。从以前的div+css网格化布局到JavaScript的方兴未艾，然后是各种JavaScript框架的百家争鸣，HTML5和CSS3的落地，移动web冲击下带来的响应式设计，jQuery,AngularJs,ReactJs等操作DOM元素截然不同的理念和方式，web component的标准化进程&hellip;&hellip;为什么现在企业到处都在招前端工程师？好像突然之间，前端工程师成了稀缺资源。这里的原因之一就是很多前端工程师跟不上行业变化，无法达到目前市场上对前端工程师的能力和要求。在这种大环境下，工程师能够掌握快速学习的能力就变的至关重要。</p>

<!-- more -->


<p>笔者根据自身的亲身体会，以及结合对周围同事的观察，对如何快速掌握一门新技术（这里的技术包括一门新的IT技术，包括一门新的编程语言，抑或一种新的程序框架等）有着以下几点指导。</p>

<p>要想快速掌握一门新技术，首先有两个先决条件。</p>

<ol>
<li><p><strong>首先思想要主动求变，敢于跳出的自己的舒适区，对任何技术都抱有开放的心态。</strong>贪图安稳是人的本性。而这种本性往往会阻碍你的发展。人所能了解的知识的多少，取决于自己的舒适区有多大，舒适区越大，与外界接壤的范围越大，就越感觉自己的无知。程序员至少要做到两点，<strong>不要对自己不了解的技术心存偏见，不要对自己不熟悉的技术心存恐惧</strong>。</p></li>
<li><p><strong>要化被动式学习为主动式学习。</strong>在中国很大一批程序员每天都是在被动式学习。什么是被动式学习？就是被人、事逼着去学习。今天新启动一个项目，技术调研不想采用新的技术，开发过程中碰到难题才会去查资料，整天就是把别人的、自已以前写的代码复制重用，复制以后出问题了也要花好长时间解决。举个例子，一个程序员使用了Spring好几年，都不知道Spring的核心理念，不知道Spring框架结构，不知道Spring各个组件功能，不知道Spring新版本的新特性。这是非常可怕的，因为你不知道这些东西，就无法采纳Spring的最佳实践，出现问题不知道如何快速定位，项目中的某些需求就无法使用Spring早已封装好的功能（因为你不知道Spring还能干这个）。主动式学习需要你未雨绸缪，不能临时抱佛脚。而且要把学习看做是对自己的积累和提高，看成是对自己的长期投资，不能抱有太强的功利性。</p></li>
</ol>


<p>有人说，我就是喜欢舒适区，我就是不喜欢主动学习，有什么好的方式和方法改变这两点？说实话，我所能提供给你的帮助很有限。正如《后会无期》里的一句台词，“我听过很多大道理，可依然过不好这一生”。这两点还是更要靠你个人来实现。而接下来的一些点，我相信可以帮助到你。</p>

<ol>
<li><p>学习一门新技术前，先要搞清楚为什么要学习它？没这个技术前我们是怎么干活的？有了它以后我们又是怎么干活的？它带来了哪些改变？其实问这些问题，就是为了了解该技术解决或者简化了那个问题域的问题，又是采用了什么方式达到了这样的效果。就拿AngularJS为例，AngularJS最初是为了弥补HTML构建应用的不足。以前的HTML在设计时是为了展示多媒体信息，后来虽然拓展了一些动态功能，但是在应用web化的潮流下，HTML设计上的不足就越来越突出。比如DOM元素操控太繁琐、业务逻辑很难模块化、可测性低、开发效率底下等。而AngularJS采用了一种全新的设计来解决该问题，它提出了一系列概念，引入了数据绑定、标识符、路由、依赖注入等特性，大大简化了我们开发WEB开发的工作量。通过这样的方式能迅速建立起了对该技术的宏观认识，了解了其潜在的应用场景、应用方式以及一些局限性等。</p></li>
<li><p>接下来就要实际使用一下该技术的核心的功能，强化对它的认识。方式就是参考该技术官网的Quick Start（快速开始）章节，一步一步来。<strong>现在的程序员越来越珍惜时间，文档的简洁性、完备性、易上手都成了是否采纳某项技术的指标之一。尤其是现在的各种开源组件，连文档都是开源的。</strong>所以很多文档都是完全按照程序员的思维写的，读起来很清爽。再拿Spring来说，想学习Spring4.0推出的Spring boot组件，那么可以访问其<a href="http://projects.spring.io/spring-boot/">官网</a>，页面上最大的按钮就是Quick Start。点击学习吧。页面是一个简单的例子，可能花不了你五分钟。如果还没过瘾，右边又列出了更多的Getting Started Guides，也是一步一步的教你进阶功能。有些人可能要问了，英语不好怎么办？请学英文。<strong>英文是一个优秀程序员的必备技能。</strong>可能也有人说，看文档时有各种杂音咋办。比如看Spring boot的start guide，需要之前对Spring有一定了解，需要知道tomcat、jetty是干啥的，需要有一定gradle或者maven使用经验…这些知识在演练Spring boot的那个小程序时都需要，但由于这些杂音的干扰，会拖慢学习的过程。摆脱这些杂音的唯一方式就是，对于那些不了解的知识点，也花时间去学习吧。<strong>所以学习是一个良性循环的过程，学的越多，就学的越快。</strong></p></li>
<li><p>前面两步能够保证你对一门技术入门，那么如何进阶那？这个阶段就是读了。从官网上把该技术的详细文档扒拉下来，使劲读吧。通读这些文档能让你进入它的实现细节，以及各种使用方式与场景，甚至一些最佳实践。比如Spring boot<a href="http://docs.spring.io/spring-boot/docs/1.3.0.M3/reference/htmlsingle/">官方文档</a>，详细到了牙齿。凡是你想到的、没想到的，文档都贴心的列了出来。如果你想学习Scala，那么请访问<a href="http://www.scala-lang.org/documentation/">http://www.scala-lang.org/documentation/</a>，各种文档应有尽有，读完就是大半个Scala专家。<strong>一门技术最好的文档必须是它的官方文档</strong>，如果不是，那么这门技术火不了。注意通读文档的过程中一定要在项目加以运用。如果在项目中没实践机会，自己可以写一些小的demo来实践。学习知识时实践与理论相结合的道理恒古不变。</p></li>
<li><p>走完前三步，你对这门技术的理解已经比大多数人强了。你可以算掌握这门技术了。那么还有进阶方式没？当然有，那就是把你所学、所想讲出来，写出来，暴露在公众之下，接受批判，从而发现自己的不足，促使你进步。有空给大家做几个讲座，写几个系列文章，那么你在大家眼中就成了这门技术的牛人。你就有了各种机会来解决使用该技术遇到的各种疑难杂症，反过来加深和修正你的理解。没事上上StackOverFlow，回答别人几个问题，或者订阅该技术的问题列表，经常看一看。</p></li>
<li><p>还可以再继续深入。加入国内/国际技术社区（国内没这样的社区咋办，机会来了，赶紧自己建一个），进一步发挥自己影响力。翻译、编写与该技术相关的书籍；如果该技术是开源的，那么有时间就提交修改把，自己就成了开发者一员了。这就是质的飞跃，从使用工具进阶到创造工具。</p></li>
</ol>


<p>走完5步，你已经不是仅仅掌握这门技术了，你已经超神了好吧！有人可能又会问，能达到这五步的肯定要花很长时间，不是一般人能够到的高度。那当然了，这个过程肯定很难，但并非难到登天。至少我身边有很多这样的例子。其实你只要完成前三步，你就比50%的程序员牛了，完成第四步，你已经站在90%程序员的前面。</p>

<p>最后快速总结。重要的事情说三遍。</p>

<ol>
<li><p>主动学习很重要，主动学习很重要，主动学习很重要。</p></li>
<li><p>官方文档很重要，官方文档很重要，官方文档很重要。</p></li>
<li><p>实践很重要，实践很重要，实践很重要。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[膝盖中了一箭之康复篇]]></title>
    <link href="http://www.huangbowen.net/blog/2015/08/01/recovery-after-acl-surgery/"/>
    <updated>2015-08-01T19:54:17+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/08/01/recovery-after-acl-surgery</id>
    <content type="html"><![CDATA[<p>7月1日手术。手术完后即按照护士要求做踝泵及伸腿运动，次数多少记不得了，反正300次应该是有的。护士说不能下地，但我坐床上实在无法撒尿，最后还是站在床边撒的。</p>

<!-- more -->


<p>7月2日早上刚开始发现不能直抬腿，主要是大腿肌肉可能麻醉效果还没过，完全无法收紧肌肉，膝盖部位一点力气都没有。自己尝试侧着身体抬腿，发现可行，练了一个小时后，突然发现能平躺着直抬腿了。然后使用CPM机做曲腿练习，70度无压力。下午护士教了床边垂腿及下地双拐走路。之后上厕所都是自己拄拐去的。</p>

<p>7月3日早上器械弯腿能到80度。每天早上2次冰敷，下午1次冰敷。自己也练了直抬腿及各种角度抬腿。麻药效果完全消失，伤口缝合处碰到了会火辣辣的痛。下午为了吃一份加节子的肥肠粉，走了40分钟才到吃饭的地方，回来又花了40分钟。</p>

<p>7月4日CPM机弯腿到90度（由于CPM机有偏差，实际有75度左右）。</p>

<p>7月5日CPM机弯腿到100度（实际有85度左右）。</p>

<p>7月6日CPM机弯腿到110度（实际有95度左右）。</p>

<p>7月7日CPM机弯腿仍然是110度。膝盖有些肿，所以没敢继续加角度。床边垂腿已经可以大于90度了。</p>

<p>这几天每天早上都是CPM弯腿40分钟，冰敷两次，每次15分钟。电疗一次，20分钟。下午冰敷1次，15分钟。床边垂腿练习，10分钟。期间自己间歇进行抬腿练习。</p>

<p>7月8日出院。下午尝试了下脱拐走路，发现没问题。但为了保险起见，没有多走。由于膝盖轻微肿胀，所以垂腿角度仍然是90度。</p>

<p>7月9日再次尝试脱拐，发现走的更稳了。遂带上支具，改为单拐走路。下午彻底脱拐。</p>

<p>7月10日把纱布去了发现膝盖肿的有点凶，遂加强冰敷，并且改为单拐走路。已经两天没练弯腿了，想等着肿胀减轻点再练习。没事就去网上、贴吧查看各种康复训练资料。决定这一个月内主、被动角度练到90度就行了，不着急突进角度。</p>

<p>7月14日早上去北京出差。保险起见带了支具，只带了一个拐。可以走特殊通道过安检，上飞机也可以走商务舱通道，挺爽的。但是在飞机上就不爽了，由于腿无法弯曲，坐在位置上难受惨了，而且飞机还晚点。到了北京已经下午了，入住酒店已经6点过。从机场到酒店又是大巴、又是地铁把我折腾惨了，早说打的。7月15日要上台讲课，站了1个小时，还好。由于会议在国家会议中心，在鸟巢、水立方隔壁，我又拖着拐去鸟巢、水立方那边逛了逛。15号晚上坐飞机回成都，到成都已经12点了。膝盖还是有些肿，里面积液较多。</p>

<p>之后的几天就呆在家里休养。弯腿也突然突破90度了，弯到100度无压力，再弯曲的话就痛了，最好的时候能到110度。</p>

<p>7月20日开始上班。第一天上班打的车，带了支具和拐。到了公司以后拐很少用，还是带着支具走来走去。</p>

<p>7月25日尝试开车，发现可行，没有任何不适。（自动挡的车，踩刹车和油门完全没问题，和好腿一样反应灵敏）一个月没开车了，车的不像样子了。自己把车洗了，开出去溜了溜。</p>

<p>晚上尝试了靠墙静蹲，一次能坚持2分钟。虽然自己走路挺早，但是股四头肌和小腿肌肉还是萎缩明显。大腿萎缩了3厘米左右，主要是以前大腿肌肉发达，而制动后肌肉消失特别快。</p>

<p>7月27日开始上下班开车。由于路上堵，上班通常要开1个小时左右，其实只有13公里，一半时间堵在路上。1个小时下来腿还是有点涨。</p>

<p>7月29日去杭州出差，需要出差一个月左右。</p>

<p>时间过的很快，已经是做完手术1个月了。医生说1个月的时候要去复查，我现在出差也回不去，等到2个月的时候再复查。</p>

<p>自从出院后的康复一直断断续续，弯腿是每天一次，冰敷以前是每天2次，上班后就改成了晚上弯腿了冰敷了。现在出差了虽然带了冰袋，但没冰箱也没冰敷。膝盖的肿胀减轻了很多，里面还是有积液，所以看起来有点肿。弯腿主动能90，被动110多度，不到120，自己觉得进度可以，也没下狠心扳。现在走路不带支具（在客户现场，带支具有些别扭）、不拄拐，走的挺稳的，看起来只是稍微有点瘸。不过上下楼梯还是无法交叉步，只能一步步来。</p>

<p>接下来待出差的事情理顺后就打算找个健身房开始有规律的康复性训练了。自己之前在健身房泡过8个月，所以基本知识、基本动作还是知道的。希望能早日开始跑步训练，自从4月18日大连100越野赛后就再没跑过步，不知道跑步是什么滋味了。参加比赛更是遥遥无期，至少也要在半年后了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[翻译-Salt与Ansible全方位比较]]></title>
    <link href="http://www.huangbowen.net/blog/2015/07/21/salt-vs-ansiable/"/>
    <updated>2015-07-21T15:15:47+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/07/21/salt-vs-ansiable</id>
    <content type="html"><![CDATA[<p>原文链接：<a href="http://jensrantil.github.io/salt-vs-ansible.html">http://jensrantil.github.io/salt-vs-ansible.html</a></p>

<p>作者： Jens Rantil</p>

<p>之前某些时候我需要评估配置管理系统。结合从他人得到的意见，我认为<a href="https://puppetlabs.com/">Puppet</a>及<a href="http://www.getchef.com/">Chef</a>在配置和运行方面过于复杂。由于我是Python粉，所以我时常关注<a href="http://www.ansible.com/home">Ansible</a>及<a href="http://www.saltstack.com/">Salt</a>。Ruby目前不是我感冒的语言，当然我也不想在这里引起语言之争。</p>

<!-- more -->


<p>去年我花了6个月美好的时光用Ansible来配置服务器。从而对这个工具变得很熟悉。在那个项目中Ansible可以说是最佳选择，因为它易于使用，还有完整的文档。我所工作的团队尽量遵循文档中指示的<a href="http://docs.ansible.com/ansible/playbooks_best_practices.html">最佳实践</a>，从而使我们快速上手，而且我们可以借鉴已经被验证过可以工作的结构。</p>

<p>几周前我去日本开始为期10天的休假，在一个完全没人认识我的地方，我有充足的时间来阅读一些电脑杂志和文档。享受了美味的寿司，观赏了东京美景，玩耍了滑雪之余，我发现阅读<a href="https://media.readthedocs.org/pdf/salt/latest/salt.pdf">Salt PDF文档</a>是一个很棒的休闲。</p>

<p>当然我花了一些时间来试用Salt并使用了<a href="http://docs.saltstack.com/en/latest/topics/tutorials/starting_states.html">States</a>系统。现在我认为我对两个系统有了一个粗略的背景，我义无返顾的进行了一个具有个人色彩的测评。</p>

<h2>术语</h2>

<p>Salt及Ansible创建之初都被作为执行引擎。即，它们都可以在一台或多台远程系统中执行命令，并且可以并行执行。</p>

<p>Ansible支持在多个机器上执行任意的命令行命令。它也支持执行模块。一个<a href="http://docs.ansible.com/ansible/modules.html">Ansible模块</a>基本上是以对Ansible友好的方式编写的Python模块。大多数标准的Ansible模块是幂等的。这意味着你只需告诉你的系统想要的状态，那么该模块就会尝试将你的系统调整为该状态。</p>

<p>Unusable也有<a href="http://docs.ansible.com/ansible/playbooks.html">Playbook</a>的概念。一个playbook是为一组主机定义了一系列模块执行顺序的文件。playbook可通过执行模块来改变主机准柜台。这使得我们可以精准控制多台机器，比如在升级一个应用程序之前把机器从负载均衡器中剔除出去。</p>

<p>Salt有两种模块：<a href="http://docs.saltstack.com/en/latest/ref/modules/all/index.html">执行模块</a>和<a href="http://docs.saltstack.com/en/latest/ref/states/all/index.html">状态模块</a>。执行模块可以简单的执行一些命令，比如执行命令行命令，或者下载一个文件。状态模块与Ansible模块更相似，通过参数定义一个状态，而模块则尝试满足该最终状态。通常状态模块调用执行模块来完成工作。</p>

<p>状态模块执行时使用state执行模块。状态模块支持通过文件定义状态，该文件被称为SLS文件。而状态与主机的映射关系被定义在<a href="http://docs.saltstack.com/en/latest/ref/states/top.html">top.sls</a>文件中。</p>

<p>playbook及SLS文件（通常）都是使用YAML格式。</p>

<p>另外，我想指出当任务需要使用inventory,或者需要在多台机器上运行时，使用远程执行引擎是非常有用的。</p>

<h2>架构</h2>

<p>Salt有一个Salt master，而很多Salt minon在初始化时会连接到该master上。通常，命令起始于master的命令行中。master然后将命令分发到minion上。初始化时，minion会交换一个秘钥建立握手，然后建立一个持久的加密的TCP连接。我可以喋喋不休的阐述Salt如何借助<a href="http://zeromq.org/">ZeroMQ</a>库来通讯，但简短的来说，Salt master可以同时连接很多minion而无需担心过载，这归功于ZeroMQ。</p>

<p>由于minion和Salt master之间建立了持久化连接，所以Salt master上的命令能很快的到达minion上。minion也可以缓存多种数据，以便加速执行。</p>

<p>Ansible无需master，它使用SSH作为主要的通讯层。这意味着它比较慢，但无需master意味着它在设置及测试Ansible playbook上更加容易。有人也声称它更安全，因为它不需要额外的服务器程序。你可以在“安全”章节获取更多信息。</p>

<p>Ansible也有支持ZeroMQ的版本，但需要一个初始的SSH连接来设置。我尝试了这个，但说实话我并没感到速度有所提升。我猜如果playbook更大，主机更多时才会感受到速度的提升。</p>

<p>Ansible推荐使用inventory文件来追踪机器。inentory文件基本上包含了一组主机，可以对其分类为组，可以对一组主机或单个主机指定属性。你可以建立多个inventory文件，比如一个作为阶段环境，另一个作为产品环境。</p>

<p>Salt也支持使用SSH替代ZeroMQ，即<a href="http://docs.saltstack.com/en/latest/topics/ssh/">Salt SSH</a>。但请注意目前还是试用版本（而且我还没尝试用过）</p>

<h2>社区</h2>

<p>对于这两个项目我都有使用IRC及邮件列表的经历。我也给它们发过补丁包，包括Python代码及一些文档修正。以下是我的经历的总结：</p>

<p>Ansible：IRC上反馈非常快，并且很友好。但该项目貌似缺少社区影响，更像是一个人在领导，即Michael DeHaan。抱歉我这样说，其实我很喜欢社区，因为对于改进更加开放和友好。Ansible一些改进问题还未修复就关闭了，让我感觉它把问题隐藏了起来。好在所有的问题都有回答。</p>

<p>Salt需要继续证明其欢迎社区贡献。IRC反馈已经变得及时和友好。有时我需要借助于邮件列表。我有一些邮件，直到4天以后才得到响应，但看起来每个邮件最终都会有跟进。</p>

<p>我的印象是Salt有更成熟的社区，更欢迎协作。我说这句话时可能会得罪很多人，当然这是我个人观点！</p>

<h2>速度</h2>

<p>如果你以为你的服务器比较少，速度无所谓时，我相信你是错的。能够快速迭代永远是非常重要的。长期来说，配置缓慢会拖慢你的整个节奏。如果有些东西需要花费30秒以上来编译，我会在编译时去玩Twitter，而这意味着该编译会其实会花掉至少120秒。部署时也会这样。</p>

<p>Ansible始终使用SSH来初始化连接。这很慢。也许Ansible的ZeroMQ实现（之前提到过）会改善这点，但初始化依然会很慢。Salt默认使用ZeroMQ，所以很快。</p>

<p>之前说过，Salt拥有持久的minion进程。这使得Salt可以缓存文件，从而加速执行。</p>

<h2>代码结构</h2>

<p>我最不能忍受的是Ansible模块不能被导入（因为<a href="https://github.com/JensRantil/ansible/blob/devel/library/files/copy#L189">导入就会执行代码</a>）。这意味着测试模块时会引入一些魔法。因为你无法导入任何一个模块。我不喜欢魔法，而喜欢纯粹简单的代码。这更像Salt的风格。</p>

<p>少用魔法意味着给Salt模块写测试更清晰。Salt完全可测。我很高兴Salt关于<a href="http://docs.saltstack.com/en/latest/topics/development/tests/unit.html">测试</a>有三个章节，包括鼓励你mock一些你不具备的基础设施来增加可测性，比如mock一个MySQL实例。</p>

<p>以上说明Ansible通常拥有简洁干净的代码。我在其中可以快速跳转。然而，<a href="https://groups.google.com/forum/#!msg/ansible-project/mpRFULSiIQw/jIIQdOSubnUJ">提升代码结构</a>不是“Ansiable社区”的关注点。</p>

<p>Ansible和Salt都可以通过<a href="https://pypi.python.org/pypi/salt">PyPi</a>来安装。</p>

<h2>Vagrant支持</h2>

<p>当讨论测试时，DevOps人喜欢Vagrant。直到现在我还没用过它。Vagrant可以使用Slat和Ansible提供的模块来初始化机器。这意味着在初始化机器时，Vagrant可以轻而易举的使用master+minion模式，或者执行一个playbook。</p>

<h2>任务编排</h2>

<p>Ansible和Salt都支持编排，我认为Ansible中编排规则更容易理解和使用。基本上，playbook可以分割为多个任务组，每组匹配一组主机（或主机组）。每组按顺序来依次执行。这与任务的执行顺序相同。</p>

<p>Salt支持<a href="http://docs.saltstack.com/en/latest/topics/event/index.html">事件</a>和<a href="http://docs.saltstack.com/en/latest/topics/reactor/">反应器</a>。这意味Salt执行可能会触发另一个机器上的东西。Salt的执行引擎也支持监控。所以未来这块前景比较广阔。你可以使用<a href="http://docs.saltstack.com/en/latest/ref/states/overstate.html">Overstate</a>在集群中以特定顺序设置多种角色来实现基础编排。</p>

<p>Ansible比Salt在编排方面更好，因为它简单。Salt将来会更好，因为在集群变化中它更具持续反应性。</p>

<p>Salt及Ansible都支持通过机器窗口执行任务。这对于保证服务始终可用（比如升级时）是非常有用的。</p>

<h2>安全</h2>

<p>Ansible使用SSH来传输数据。SSH是经历过考验的协议。一旦SSH服务器被正确配置（使用一个良好的随机数生成器），我相信大多数人会认为SSH客户端是安全的。</p>

<p>Ansible也可以轻松的建立多个非root用户与单个主机的连接。如果你非常反对有进程以root权限运行，那么你可以考虑使用Ansible。Ansible支持使用sudo来以root方式执行模块。所以你可以无需使用root来建立SSH连接。</p>

<p>Salt使用“自己”的AES实现及key管理。我想指出这里的“自己”其实是使用<a href="https://www.dlitz.net/software/pycrypto/">PyCrypto</a>包。Salt<a href="http://www.cvedetails.com/vulnerability-list/vendor_id-12943/product_id-26420/version_id-155046/Saltstack-Salt-0.17.0.html">以前</a>有安全问题，但同时我认为Salt架构很简单，所以安全问题可以轻松的维护。</p>

<p>有点需要指出，Salt运行master及minion时默认以root方式。这个配置可以改，但显而易见会导致一些新问题，比如非root模式下很难安装Debian包。在master上你可以配置salt命令为非root模式。我极力推荐这样做。</p>

<h2>敏感数据</h2>

<p>所有敏感数据应当单独存放，然后在需要时存放在配置机器上。如果配置机器是系统管理员的机器（现在通常是笔记本电脑），那么会有数据被盗用的风险。</p>

<p>经过深入的长时间思考后，我认为认证master方式是更好的选择。这意味着敏感数据可以强制存放在一个受保护的地方（当然需要加密的备份）。Salt可以把安全证书存放在”Pillar”里。当然，破解master会是个毁灭性打击，但是同时我们只需要安全保护一台机器。不是所有的开发者电脑都是安全的，尤其在火车上或飞机场时。</p>

<p>显然，Ansible用户可以选择始终通过一个绝对安全的存放敏感数据的电脑上执行playbook。但人们通常会这样做吗？</p>

<h2>审计能力</h2>

<p>当讨论安全时我认为审计是相当重要的。Salt在这方面比Ansible做的要好。Salt的每次执行都会在master上<a href="http://docs.saltstack.com/en/latest/topics/jobs/index.html">存放</a>X天。这样我们更容易调试，也容易发现可疑的事情。</p>

<h2>部署</h2>

<p>Ansible显然更容易些。因为它无需部署。当然，Salt支持SSH，但文档中大多数情况下假设我们使用ZeroMQ的方式。当然，SSH要慢些。</p>

<p>初始化minion的好处是这些minion都会连接到master。这使得我们可以快速初始化很多新机器。如果你想使用类似于亚马逊的自动化弹性扩展功能时，minion-连接架构很有用。每一个自动化弹性扩展的机器将自动变为一个minion。</p>

<p>Salt <a href="https://github.com/saltstack/salt-bootstrap">初始化脚本</a>非常好用，而且执行很快。可以处理不多种分发，文档也很<a href="http://salt.readthedocs.org/en/latest/topics/tutorials/salt_bootstrap.html">丰富</a>。</p>

<h2>学习曲线</h2>

<p>Ansible这方面更好。Ansible更容易学习及提高。因为我们只需拷贝一份Ansible GIT代码库，然后设置一些环境变量就可以执行playbook了。</p>

<p>Salt可以以<a href="http://docs.saltstack.com/en/latest/topics/tutorials/quickstart.html">非master模式</a>运行。这样可以更容易设置和运行salt。然而，对于产品环境（以及阶段环境）我推荐使用master模式来运行Salt。</p>

<p>通体来说，Salt功能更花哨，代价是学习曲线陡峭。Salt<a href="http://docs.saltstack.com/en/latest/topics/development/modular_systems.html">更加模块化</a>。这易于组织代码结构，但是完全精通Salt需要更多学习。</p>

<h2>升级</h2>

<p>升级Salt取决于当时是如何安装Salt的。基于Debian的分发的话，有一个apt代码库来存放最新的Debian包。所以升级的话可以使用apt-getupgrade。对于Ubuntu机器，有PPA。这些代码库的维护很活跃。最新发布的2014.1.0版本一周内（时间有点长）就有了Debian/Ubuntu包。</p>

<p>升级Ansible更简单。你只需简单执行git fetch &amp;&amp; git checkout <tag>即可。</p>

<h2>文档</h2>

<p>两个项目都有详尽的文档供你设置和运行，以及开发模块及配置。过去Ansible比Salt有更好的文档结构。最近Salt花了<a href="https://github.com/saltstack/salt/issues/10526">大力气</a>来重整文档。我也贡献了自己的力量来帮助完善这些文档。</p>

<h2>结语</h2>

<p>对于我来说，Ansible是个极好的工具来自动化服务器配置及自动化部署。设置Ansible并运行起来很简单，而且文档也很丰富。</p>

<p>进一步说，Salt具有可伸缩性，速度快，架构合理。我发现Salt的结构更适合云端部署。将来我会毫不犹豫的使用Salt。</p>

<p>总的来说，你在做出选择之前最好在你的项目中都试用下它们。反正配置及测试Ansible及Salt都非常快。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[膝盖中了一箭之手术篇]]></title>
    <link href="http://www.huangbowen.net/blog/2015/07/08/acl-recovery/"/>
    <updated>2015-07-08T13:43:42+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/07/08/acl-recovery</id>
    <content type="html"><![CDATA[<p>虽然5月份已经确诊了前十字韧带断裂，但由于公司项目一时走不开，无法立即手术。几番协商以后，终于确认手术时间定于6月底。期间专门挂了胡勇的6月17日的门诊，让他给看了看。胡主任让助手给我做了各项检查，结合MRI结果，得出了我的前交叉韧带肯定断裂了的结论。所幸我的半月板没有任何问题。顺便我也去了住院部，想预约6月27日住院。但护士告诉我只有提前两天打电话才行。</p>

<!-- more -->


<p>6月25日给住院部去膝关节科打电话，被告知26日可以办理入院，周末不办理入院。无奈第二天请假去办理入院手续。早上办完入院手续已经快中午了。下午又做了各项检查，晚上还溜出去和公司同事team building。由于星期六早上5点要抽血，所以周五在医院睡的。我被分配的是膝关节科最大的一个病房，有七张床位，人多虽然热闹，但晚上比较吵，一晚没睡好。五点多护士MM来抽血，一口气就抽了五大罐。</p>

<p>周六周日一般都不安排手术，所以我也没啥事情，就溜回家了。周末都在家里过的，差点让我忘记了我还在住院。期间护士打了好几次电话，催我赶紧回去。</p>

<p>周一回到病房，主治医生和住院医生查房，确定了我的手术被安排在周三。护士告知手术前一天晚10点钟过后直到手术完成后2小时都不能吃东西和喝水。住院医生也给我们讲了手术的方案和风险。由于以前我已查阅过大量的资料，所以整个过程还是去比较清楚。手术确定了自体双束重建的方案，优先取患肢大腿内侧处肌腱编制为韧带。如果强度不够，则再取其它地方。</p>

<p>周三早上换上手术服就在病床上等候。期间护士给刮了腿毛，还给右腿缠上了一个带子。一直等到中午12点才有护工来接我去手术室。先是给我推到了麻醉室，麻醉师给我右腿打了一针，顿时右腿肌肉就不听使唤了，不停的跳，感觉有股暖流在流动。过了一会才把我真正的推到手术室。手术室的样子和电视里看到的差不多。期间主治医生不断地摆弄我的腿以便将器械调到合适的位置。我发现身体不停的抖动，不知道是麻醉的效果还是由于害怕。麻醉师在反复确认我身份后，给我的左手推了几针，顿时左胳膊剧痛无比。我问麻醉师：“怎么左胳膊这么痛？”麻醉师说他正在给我推麻药。然后他拿了一个类似于氧气罩的东西放在我嘴边让我吸。我只吸了几口顿时就睡着了。</p>

<p>当我醒来的时候是被人拍醒的。看到护工正打算把我往病房推。我问：“手术成功了没？”有个医生说：“成功了。”到了病房后我才发现我的右腿被包成了粽子。可能右腿的麻醉还没完全过，疼痛还在忍耐的范围之内。这时候护士就让我多练习下泵踝，就是钩右脚掌和伸右脚掌。晚上一夜没睡好，痛倒是可以忍受，就是腿不能动，翻身之类的都极其困难。</p>

<p>第二天一大早护士就来查房，让我直抬腿。我试了几次都不行，感觉大腿肌肉完全不受控制，不能紧绷，膝盖那块也没感觉。我发现侧着抬腿可以，就试着先侧抬腿。就这样练了一个小时，突然发现可以直抬腿了。主治医生也来查房了，看到我能直抬腿，说我肌力不错，下午可以下床了。早上护士还拿了一个帮助弯腿的机器来让我联系弯腿，这天只试了70度，感觉还行。下午护士教了如何下床和床边垂腿。终于可以去厕所撒尿了。</p>

<p>第三天早上又是冰敷、电疗、使用机器弯腿。这次加到了80度，感觉还好。只不过麻醉效果完全过了，缝合的伤口处如果碰到就会钻心的痛。之后这几天都是老三样，直抬腿、床上曲腿、床边曲腿。我的角度练的还可以，术后6天被动角度可以到110，床边垂腿角度可以到90。练习康复动作各种酸爽，那感觉简直不摆了。</p>

<p>7月7日住院医生蒋医生通知第二天可以办理出院了。我当天又偷偷溜回家休息。7月8日早上回到医院，办理了出院手续。住院期间总共花费31000元不到，社保报销了16000多，自费了14000多。伤不起。</p>

<p>接下来就是漫漫的自我康复之路。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何培养自信心]]></title>
    <link href="http://www.huangbowen.net/blog/2015/06/16/how-to-build-self-confidence/"/>
    <updated>2015-06-16T17:58:46+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/06/16/how-to-build-self-confidence</id>
    <content type="html"><![CDATA[<p>self-confidence（自信心）——是一种反映个体对自己是否有能力成功地完成某项活动的信任程度的心理特性，是一种积极、有效地表达自我价值、自我尊重、自我理解的意识特征和心理状态，也称为信心。自信心的个体差异不同程度地影响着学习、竞赛、就业、成就等多方面的个体心理和行为。</p>

<!-- more -->


<p>当你被指派一个任务时，你会基于你目前所拥有的资源和能力做出一个评估，结果得出自己是否能胜任这个任务。自己目前能力&lt;该任务所需能力，你却得出能胜任的结论，那就是你对自我认知不足，盲目乐观，这就是自负的表现。自己目前能力 >=该任务所需能力，而你却认为无法胜任，那就是过于贬低自己，这就是自卑。</p>

<p>从自负被打回原形比较容易，因为你多自负几次，多栽几个跟头，那么你就老实了。而从自卑上升到自信则难多了，因为由于自卑，你根本不会去领取任务，这意味着你不会完成该任务，从而无法提升自信，有新任务来时又主动退缩，陷入死循环。</p>

<p>所以大家可能看出来了，培养自信心的关键在于，多做事，做没做过的事。不断的检验自己，校正自己对自己的认知。但是大家在面临工作中的挑战时，报的都是比较谨慎的态度，因为事情没做成，轻则挨顿骂，重则丢了饭碗，所以又陷入一个死循环，谨慎接任务->无法突破自身->自信心（能力）无法提升->谨慎接任务。</p>

<p>所以培养自信心可以从生活中的事情开始。有一个很好的任务就是跑一个马拉松。如果你之前没有跑过马拉松，那么你肯定有很多问题想知道。</p>

<ol>
<li>马拉松距离有多长？</li>
<li>跑马拉松需要什么样的装备？</li>
<li>从现在开始训练，需要多长时间能够完成马拉松?</li>
<li>需要什么样的训练计划？</li>
<li>如何安排自己的训练时间？</li>
</ol>


<p>这么多的问题要把你淹没，自己完成一个马拉松似乎变成了一个不可能的任务。如果这时你退缩，那么我可以告诉你，你自卑了。因为据科学家研究，一个普通人，只要你没某些不适合跑步的疾病（比如心脏病等）以及肢体残疾（有些残疾人也能完成马拉松），通过训练都可以完成42公里的跑步。我说你行，你缺少的就是干劲。</p>

<p>虽然有这么多问题，你还是决定试试。那么首先要解决这些问题。如何解决不需要我教了吧？网上一查，资料一大把。多去跑步圣经、跑步吧里逛逛，买几本关于跑步的书，找几个身边的长跑健将聊聊天，大多数的问题都迎刃而解。小部分的问题可能会使你纠结，比如有人说跑步需要3呼3吸，有人说2呼2吸，有人说亚索800方法好，有人说MAF有奇效。不用纠结，你要进入下个环节了，实战训练，从训练中感知这些理论方法，从而找到更适合自己的方式。</p>

<p>刚开始训练感觉新奇，时间久了似乎各种问题又来了。最近太忙，训练时间很难保证；跑了这么久，距离还是无法突破；到底是先练距离还是先练速度那？&hellip;&hellip;.说时间紧的那我劝你不练了。因为咱们的任务就是跑一个全程马拉松，你没时间训练，那就别干了。这就好像老板喊你7天搭一个网站出来，你说对不起最近LOL正在冲击排位，没时间做。跑马拉松这件事本来就是你自己给自己定的任务，老板就是你自己，所以时间问题你看着办。其它问题好说，搞IT这行的最不缺的技能就是利用资源。多看书、多逛跑步论坛、多找过来人交流….(怎么还是老三样)再加上自己在训练中融会贯通，我就不信你不长进。</p>

<p>好了，经过一段时间训练了，感觉自己进步很大，但还是拿不准啥时候能跑个全马。如果你想达到“万事俱备，只欠东风”，那么对不起，你不是诸葛亮，东风啥时候来你是不会知道的。这就需要你设置个deadline了。先报名一个几个月后的全马比赛（一般马拉松比赛都是提前几个月报名），然后你的训练会更加鸡血。而且你会找到一群志同道合的基友（没找到？不知道咋找？我膝盖前叉断裂，都轻松找到了一群病友，你到底用心没？），一起集训，相互鼓励。</p>

<p>比赛的日子越来越近了。回想这几个月来，你为了这一目标付出了这么多实打实的汗水，肯定感慨良多。你认识了一群基友，熟悉了周边没逛过几次的公园，看到了早晨7点钟的城市，学会了跑步中对自我反思&hellip;.恭喜你，这些都是跑马拉松给你带来的从来没有的体验。虽然在迎接这天的过程中，你激动的内心有些忐忑，但是你似乎已经得到了很多意想不到的东西。</p>

<p>比赛这天终于到来了，站在起点前，和好几万人一起打算度过数小时的地狱旅行。这时你的心里除了激动还是激动。比赛结果其实已经不重要了，当你站在跑道上的时候，你就比以前的你强了。如果能顺利完赛，你已经不是以前的你。如果因故未完赛，放心，这绝不是你最后一场马拉松，相信你已经谋划下一次冒险了。</p>

<p>好了，你已经完成了生活中的一个任务了。有没有收获？自信心有没有提升？你试一下你就知道了。可以放心的告诉你，这种感觉绝对比你考试得了全班第一的感觉还要美好。另外，跑完马拉松不是你这个任务的终点。它就像给你打开了一个潘多拉魔盒，你会发现有更多的事情你可以去做，比如铁人三项，比如越野跑&hellip;&hellip;</p>

<p>好吧，可能有点标题党。明明讲如何提升自信心，但通篇却在讲如何完成个人首马。其实很多事情都是相通的。因为你已经发现了如何做一件没做过的事情。</p>

<p>首先，先答应下来。这个最关键。</p>

<p>然后，发动所有的资源，了解这个事情。</p>

<p>接下来，做吧。别忘了边做边验证，吸收过来人的经验。</p>

<p>最后，接受检验吧。检验结果不用担心，因为无论通过与否，你整个过程已经有了大量的收获。</p>

<p>看完以后是不是有种自信心爆棚的错觉？别忘了关键两点：
1. 坚定决心要做；
2. 努力想如何做。</p>

<p>最后，尽情享受事情做成后带来的成功感和喜悦吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[膝盖中了一箭]]></title>
    <link href="http://www.huangbowen.net/blog/2015/06/08/i-hurt-my-knee/"/>
    <updated>2015-06-08T16:37:11+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/06/08/i-hurt-my-knee</id>
    <content type="html"><![CDATA[<p>从小到大，虽然没得过什么大病，但是受的伤不少。什么磨血泡、扭伤、擦伤之类的家常便饭，对于经常踢球、打球的人来说没什么大不了，休息几天又是一条好汉。高中的时候曾经骨折过2回，虽然打着石膏的时候很苦逼，但是伤好后没留下什么后遗症，也没什么心理阴影。</p>

<!-- more -->


<p>没想到去年12月踢球那次受伤这么严重。当时和同事踢球，进了几个球很嗨。在一次做急转变向时膝盖弯曲幅度过大，直接痛的坐在了地上。就是这个动作导致我前叉韧带断裂。当然这个断裂是半年后才知道的。当时休息了一会就自己开车回去了。第二天还一拐一瘸的上班。休息了一周感觉膝盖没啥问题了就又去跑步，还参加一个又一个的比赛。</p>

<p>那段时间跑了1个马拉松，一个20公里越野跑比赛，还有60公里越野跑比赛在55公里处被关门。最惨痛的是大连100公里越野赛在72公里处由于右膝剧痛而无奈退赛。这也导致我回成都后就去医院检查膝盖。检查结果出来了自己懵了，上面赫然写着前叉韧带断裂。这可是很多专业运动员得的病啊，咱一个业余的还能整的这么凶？</p>

<p>由于接连两个比赛都没能完赛，正激起我的训练决心。奈何这个检查结果把一切计划都打乱了。人生就是这样的无常，时不时的非要给你开一些玩笑。</p>

<p>从医院回来一直在考虑要不要手术。因为现在感觉也没什么大碍，走路是个正常人，跑步也没问题，只要不跑太远，只不过打球、踢球之类的就不行了。做手术人要受痛，手术效果也未知，而且手术费也不便宜，再加上手术完要静养，意味着很长一段时间内不能工作。</p>

<p>但是查阅了网上的一些资料以及一些病友的经历后，觉得手术是唯一的出路。除非你以后不想再运动了。这对于我来说肯定是不可接受的。生命在于运动，没有运动的生命是多么的暗淡。而且现在自己已经习惯了运动，修养久了反而觉得身体到处不舒服。</p>

<p>在百度贴吧和豆瓣小组很容易就找到了一群难兄难弟，还有QQ上也加了一个群，顿时算是走入了叉友们的世界（膝盖韧带损伤的人相互之间都以叉友相称）。叉友们韧带断裂或者半月板损伤的原因很多，踢足球、打篮球、打羽毛球、交通事故、攀岩&hellip;..五花八门，甚至还有走路不小心扭伤的。总体来说很多都是运动受的伤，而且深爱着这项运动。作为业余运动员膝盖受伤后如果要远离这项运动肯定都难以接受。而手术后的康复之路也是漫长的，即使完全好了也难过心理这关。</p>

<p>不过既然是爱运动的人，那么心态都比较积极，承受能力也相对大些。现在的辛苦是为了以后的再出发。通过和他们交流我也理清了一些困惑，了解了手术的过程以及大概的康复历程。知道此番路程并不容易，但也无法避免，只能尽全力度过。</p>

<p>受了伤以后，虽然尽量保持乐观，但是心态还是有些影响。比如坚持去健身房这件事情也渐渐的荒废了。这件事情肯定还要捡起来，以后做恢复训练就靠它了。</p>

<p>这次预计要休息1个月左右，这可是自从2008年开始实习以来能够休息的最长时间了。就当这是一次调整的机会吧，好好的调整下，陪陪家人，想想之后的事情。最近股市有一句话说：“深蹲是为了跳得更高！”。而这次休息是为了下次跑的更远。</p>

<p>无论什么时候，都用积极的心态去迎接挑战，迎接一切。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Grunt task中集成Protractor]]></title>
    <link href="http://www.huangbowen.net/blog/2015/06/01/integrate-protracto-to-grunt-task/"/>
    <updated>2015-06-01T12:18:57+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/06/01/integrate-protracto-to-grunt-task</id>
    <content type="html"><![CDATA[<p>Protractor是专为AngularJS应用程序编写的UI自动化测试框架。前端构建有很多构建工具，比如Grunt、Gulp等。一般我们会把这些构建工具作为集成集成的脚本执行工具。所以如果把Protractor的执行也集成进去，则可以达到自动验证UI功能的效果。</p>

<!-- more -->


<p>本文将介绍如何将Protractor命令集成到Grunt task中。</p>

<p>首先需要为Grunt安装一个插件，<code>grunt-protractor-runner</code>。这个插件会帮你在Grunt中运行Protractor。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>npm install grunt-protractor-runner —save-dev
</span></code></pre></td></tr></table></div></figure>


<p>在Gruntfile.js文件中引入该插件(如果你没有package.json文件)。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>grunt.loadNpmTasks<span class="o">(</span><span class="s1">&#39;grunt-protractor-runner&#39;</span><span class="o">)</span>;
</span></code></pre></td></tr></table></div></figure>


<p>接着在Gruntfile.js中配置protractor运行参数。需要指定protractor的配置文件路径。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>protractor: <span class="o">{</span>
</span><span class='line'>  e2e: <span class="o">{</span>
</span><span class='line'>      options: <span class="o">{</span>
</span><span class='line'>      keepAlive: <span class="nb">true</span>,
</span><span class='line'>      configFile: <span class="s2">&quot;protractor.conf.js&quot;</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在Gruntfile.js中新注册一个名为<code>e2e</code>的task，用于运行Protractor。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>grunt.registerTask<span class="o">(</span>‘e2e’,’run e2e tests’, <span class="k">function</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  grunt.task.run<span class="o">([</span>
</span><span class='line'>       <span class="s1">&#39;connect:test&#39;</span>,
</span><span class='line'>       <span class="s1">&#39;protractor:e2e&#39;</span>
</span><span class='line'>  <span class="o">])</span>;
</span><span class='line'>
</span><span class='line'><span class="o">})</span>;
</span></code></pre></td></tr></table></div></figure>


<p>此外为了不忘记自动更新webdriver的版本，可以在package.json中加入以下代码块：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="s2">&quot;scripts&quot;</span>: <span class="o">{</span>
</span><span class='line'>  <span class="s2">&quot;install&quot;</span>: <span class="s2">&quot;node node_modules/protractor/bin/webdriver-manager update&quot;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样每次运行<code>npm install</code>时会自动更新webdriver版本。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[当我完善几年前的一个老项目时，我做了哪些改进]]></title>
    <link href="http://www.huangbowen.net/blog/2015/05/15/improvement-in-a-legacy-project/"/>
    <updated>2015-05-15T11:06:55+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/05/15/improvement-in-a-legacy-project</id>
    <content type="html"><![CDATA[<p>最近几个月利用业余时间完成了一个项目。这个项目其实是2008年我在前公司做的一个web项目。后来客户想要对项目做升级，牵扯到一些功能的变动及界面的修改。由于当时整个项目的架构和主要编码都是我做的，所以前公司老总喊我来接这个项目，使用业余时间完成。我考虑了一下答应了。为了挣点钱养家就拼点呗。</p>

<!-- more -->


<p>几个月前在接这个活前，我曾写过一篇文章<a href="http://www.huangbowen.net/blog/2014/02/17/how-to-improve-a-legacy-project/">如果让我完善几年前的一个项目，我会做哪些改进?</a>。主要从工程实践的角度讲述了我将进行那些改进。</p>

<p>经过几个月的辛苦开发，终于完成了这次的功能升级，拿到了报酬。针对这种遗留系统，我来谈谈我具体都进行了那些改动。</p>

<ol>
<li><p>不用动的地方尽量不动。由于代码是08年我作为实习生写的，那代码自然惨不忍睹，有些地方写的非常累赘。经过几年打磨的我对代码质量要求已经上升了很多个层次，看到这些烂代码不禁忍不住要重构。但是我忍住了，因为这是个遗留系统，当时就没有写单元测试，所以重构过程肯定风险较大。另外工期只能用业余时间，要以新需求为主，只改开发新需求时需要碰的那些代码。</p></li>
<li><p>使用github作为代码托管服务。即使是一个人开发，也需要使用源代码管理工具，这样做起来自己心里才有底。而github自己用了好几年了，非常好用，而且自己买了github的会员。所以这次把代码以私有仓库的方式放在上面。随时写，随时提交，比自己搭建源代码服务器方便的多。</p></li>
<li><p>引入bootstrap框架作为前端框架。这次升级一个重要任务是对前端进行优化，使其能兼容多个浏览器。08年的时候大家都在用IE6，IE7，IE8都很少有人用。过了这么多年网站早都不能兼容现代浏览器了，而且屏幕分辨率适配也很差劲。作为一个前端菜鸟，我只花了一点时间学习了bootstrap，就快速把它引入到了我的项目中。我基本上把以前的css、js代码都删除了，使用bootstrap轻轻松松的就把这个老站改成了一个兼容多个浏览器，多种屏幕尺寸的网站。</p></li>
<li><p>升级.net中使用的各种组件。这个网站使用的是WebForm框架，版本为2.0。我发现在现代浏览器下WebForm组件生成的前端HTML,CSS及JavaScript存在大量不兼容的问题。网站页面变得很不稳定。当升级到4.0平台后，问题得到大大改善。另外我还使用了AjaxControllToolKit组件，发现在某些浏览器下（比如360浏览器）页面局部刷新不了。所以我也一并升级到了最新的15.3版本。虽然把各种组件都升级了，还存在一些JavaScript问题，比如日历选择框无法正常显示与选择。我采用的方法就是抛弃掉旧的JS代码，寻求成熟的JS框架来替代。比如使用bootstrap-datepicker组件来实现日历框的选取。</p></li>
<li><p>采用最新的Visual studio编辑器。微软终于想通了，与其让我们天朝成天用盗版的Visual Studio，不如直接开放一个社区版出来。我下载了Visual Studio 2013社区版，并给其装上了ReSharper组件。由于ReSharper是收费的，但是有差不多1个月的试用期。之前一直使用Intellij开发工具做开发，能在Visual Studio 2013中使用它也是觉得很爽。</p></li>
<li><p>引入了package管理工具，使用Nuget来安装、管理各种项目依赖。使用过程中我发现Nuget没有Java平台下的Maven或Gradle强大。很多依赖都不是最新版本，管理理念也不太一样。不过聊胜于无吧。像bootstrap等前端组件以及ajaxcontrolToolkit等后端组件我都是通过Nuget来管理的。</p></li>
<li><p>使用事务机制处理系统中的核心逻辑。这个系统是一个编码管理系统，主要处理炸药、雷管编码的整个流通。系统有的时候会出现重复编码的情况，比如一发雷管的编码同时存在于库存中和消耗库中。这是由于雷管从在库状态转换为消耗状态时出了问题，并没有在库存中删除该编码。这次升级我把类似的逻辑都用事务来处理，一旦发生异常就会整体回滚，不会造成脏数据的情况。</p></li>
</ol>


<p>其实我还想引入的几个点由于种种原因都没有完成。</p>

<ol>
<li><p>没有添加单元测试。本来想给Vistual Studio 2013添加单元测试框架，奈何花了几个小时都没整好。另外工程目录方面也需要进行一定的调整来引入测试项目，整了一次没搞定后也不了了之。由于这次升级80%功能是前端页面的改进，涉及后端代码修改的不多，所以没有单元测试的情况下修改已有代码还是比较有信心的。</p></li>
<li><p>没有引入持续集成。还是时间成本的原因。毕竟这个活都是使用业余时间完成的，搭建C#栈的CI估计要花上好几天，所以最后并未实现。</p></li>
<li><p>自动化部署。之前对.NET下的网站的部署都是手动的，将编译生成后的文件复制到服务器上，暂停IIS，重载文件，重新启动IIS。其实这些都是可以自动化完成的，自己没花时间研究，所以也未实现。</p></li>
<li><p>使用成熟的log框架给系统关键逻辑打上log。这个纯粹是自己懒，不想做。因为加log方便自己以后排查错误，对客户来说没有任何影响，自己就懒得弄了。</p></li>
<li><p>没有引入自动化测试。还是时间成本的原因，编写web的自动化测试太花时间了，所以只能舍弃。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用protractor操作页面元素]]></title>
    <link href="http://www.huangbowen.net/blog/2015/05/04/use-protractor-to-manipulate-dom-elements/"/>
    <updated>2015-05-04T17:02:05+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/05/04/use-protractor-to-manipulate-dom-elements</id>
    <content type="html"><![CDATA[<p>Protractor是为Angular JS应用量身打造的端到端测试框架。它可以真实的驱动浏览器，自动完成对web应用的测试。Protractor驱动浏览器使用的是WebDriver标准，所以使用起来与其他语言实现的WebDriver库大体相同。当然，我说大体相同那肯定还是有不同的地方。一旦不注意这些不同的地方就会坑到你（我就被成功坑过，所以才有了这篇文章）。</p>

<!-- more -->


<p>Protractor编写测试的核心是查找DOM元素，与其交互，然后查看交互后的状态与你的期望是否一致。所以查找DOM元素并与之交互显的非常重要。Protractor提供了一个全局函数element，其接受一个Locator对象并返回一个ElementFinder对象。该函数会返回单个元素。如果你想返回多个元素，可以使用element.all函数，其接受一个Locator对象并返回ElementArrayFinder对象。ElementFinder对象有一组方法，用于元素交互，比如click()，getText(),sendKeys等。</p>

<p>Locator对象的创建主要使用全局的by对象，其提供一些API来生成Locator对象以供element或element.all函数使用。</p>

<p>比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">//根据class名来查找元素</span>
</span><span class='line'><span class="nx">by</span><span class="p">.</span><span class="nx">css</span><span class="p">(</span><span class="err">‘</span><span class="nx">myclass</span><span class="s1">&#39;)</span>
</span><span class='line'>
</span><span class='line'><span class="s1">//根据id来查找元素</span>
</span><span class='line'><span class="s1">by.id(‘myid&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//根据ng-model名来查找元素</span>
</span><span class='line'><span class="nx">by</span><span class="p">.</span><span class="nx">model</span><span class="p">(</span><span class="err">’</span><span class="nx">name</span><span class="s1">&#39;)</span>
</span><span class='line'>
</span><span class='line'><span class="s1">//查找绑定了指定名的元素</span>
</span><span class='line'><span class="s1">by.binding(‘bindingname&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//查找指定repeater中的元素</span>
</span><span class='line'><span class="nx">by</span><span class="p">.</span><span class="nx">repeater</span><span class="p">(</span><span class="err">‘</span><span class="nx">myrepeater</span><span class="err">&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出前两个Locator的创建方法与其他语言实现的WebDriver的用法基本一样，而后几个则专为AngularJS应用设计的，方便在基于AngualrJS框架下写的web应用中查找页面元素。这是第一处不同。</p>

<p>另一处不同其他语言实现的WebDriver库使用Locator找到的元素类型是WebElement，而Protractor则返回的是ElementFinder对象。两者不同之处是在于ElementFinder对象不会立即与浏览器交互，根据指定的Locator来查找到页面上的元素；而只有当你调用了ElementFinder对象的方法时，它才会真正的与浏览器进行交互。一些常用的方法有以下所示。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="c1">//这时不会与浏览器交互获取元素信息</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nx">element</span><span class="p">(</span><span class="nx">by</span><span class="p">.</span><span class="nx">css</span><span class="p">(</span><span class="err">‘</span><span class="nx">mycss</span><span class="err">’</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//点击元素</span>
</span><span class='line'><span class="nx">el</span><span class="p">.</span><span class="nx">click</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//给该元素输入内容</span>
</span><span class='line'><span class="nx">el</span><span class="p">.</span><span class="nx">sendKeys</span><span class="p">(</span><span class="err">’</span><span class="nx">text</span><span class="err">’</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//清空元素内内容</span>
</span><span class='line'><span class="nx">el</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//获取指定属性的值</span>
</span><span class='line'><span class="nx">el</span><span class="p">.</span><span class="nx">getAttribute</span><span class="p">(</span><span class="err">‘</span><span class="nx">value</span><span class="err">’</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//获取元素的文本值</span>
</span><span class='line'><span class="nx">el</span><span class="p">.</span><span class="nx">getText</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>请注意这些方法都是异步的。所有的方法返回的是一个promise（我就吃过这个亏，以为返回的是值）。所以比如你想输出一个元素的值，应该这么写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">element</span><span class="p">(</span><span class="nx">by</span><span class="p">.</span><span class="nx">css</span><span class="p">(</span><span class="err">‘</span><span class="nx">myclass</span><span class="err">’</span><span class="p">)).</span><span class="nx">getText</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
</span><span class='line'><span class="p">})</span><span class="o">:</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你使用expect方法来验证元素的值时，expect方法会帮你取出promise中值，所以你只用这么写:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">expect</span><span class="p">(</span><span class="nx">element</span><span class="p">(</span><span class="nx">by</span><span class="p">.</span><span class="nx">css</span><span class="p">(</span><span class="err">‘</span><span class="nx">myclass</span><span class="err">’</span><span class="p">)).</span><span class="nx">getText</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">(</span><span class="err">&#39;确定’</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有不同的地方在于Protractor支持对元素查找时进行链式调用。这样的功能相当实用。你可以组合element和element.all两个函数来定位元素。并且Protractor还提供了几个辅助方法来更方便你的使用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">element</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">locator1</span><span class="p">).</span><span class="nx">first</span><span class="p">().</span><span class="nx">element</span><span class="p">(</span><span class="nx">locator2</span><span class="p">);</span>
</span><span class='line'><span class="nx">element</span><span class="p">(</span><span class="nx">locator1</span><span class="p">).</span><span class="nx">all</span><span class="p">(</span><span class="nx">locator2</span><span class="p">);</span>
</span><span class='line'><span class="nx">element</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">locator1</span><span class="p">).</span><span class="nx">get</span><span class="p">(</span><span class="nx">index</span><span class="p">).</span><span class="nx">all</span><span class="p">(</span><span class="nx">locator2</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>element.all函数提供的辅助方法有：</p>

<ul>
<li>filter： 提供一个过滤器过滤其中的元素。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='javascript'><span class='line'><span class="nx">element</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">by</span><span class="p">.</span><span class="nx">css</span><span class="p">(</span><span class="err">‘</span><span class="nx">myclass</span><span class="err">’</span><span class="p">)).</span><span class="nx">filter</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">ele</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="k">return</span> <span class="nx">ele</span><span class="p">.</span><span class="nx">getText</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">return</span> <span class="nx">text</span> <span class="o">==</span> <span class="err">‘确定&#39;</span><span class="p">;</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>get： 根据索引获取指定元素。如 element.all(by.css(‘myclass’)).get(0);</p></li>
<li><p>first: 获取第一个元素。 element.all(by.css(’myclass’)).first();</p></li>
<li><p>last: 获取最后一个元素，用法同上。</p></li>
<li><p>count：获取元素个数。</p></li>
</ul>


<p>此外还提供了each，map,reduce等方法对列表进行各种操作。</p>

<p>element函数提供的辅助方法有：</p>

<ul>
<li><p>locator: 返回locator对象。</p></li>
<li><p>getWebElement： 返回该ElementFinder包裹的WebElement对象。</p></li>
<li><p>all: 查找其一组子元素。</p></li>
<li><p>element: 查找其子元素。</p></li>
<li><p>isPresent: 元素是否在页面上展示。</p></li>
</ul>


<p>总结起来，Protractor与其它的WebDriver语言实现的区别如下：</p>

<ol>
<li><p>Protractor专为AngualrJS应用定制，其自身包含了很多wait操作，保证AngularJS脚本执行完毕后才进行下一步操作，保证了测试的稳定性与健壮性。</p></li>
<li><p>Protractor设计的By对象针对AngularJS应用提供了很多实用方法，在定义AngularJS应用页面时更加轻松。</p></li>
<li><p>element函数返回的是ElementFinder对象，其不会立即与浏览器交互，除非调用ElementFinder对象的方法。</p></li>
<li><p>调用ElementFinder对象的方法返回的是一个promise。（这点很重要）</p></li>
<li><p>Protractor在定位元素时支持链式调用。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[大连100公里越野赛_心中的痛]]></title>
    <link href="http://www.huangbowen.net/blog/2015/04/23/dl100/"/>
    <updated>2015-04-23T15:57:14+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/04/23/dl100</id>
    <content type="html"><![CDATA[<p><img src="http://www.huangbowen.net/images/airanshao.jpg" width="600">编号是0365的那个人是我</p>

<p>比赛已经于上周日结束了，但是一想到我的退赛，心中就痛苦万分。有人说，退赛比坚持更难，也许真的如此。有人说，过程比结果重要，但是过程也不完美。有人说，距离是有尊严的，那肯定是我对它不够尊重。</p>

<!-- more -->


<p>我于2014年4月份开始跑步，由于经常骑车，耐力比较好，所以一开始就是10公里。跑步的原因很简单，就是想减掉身上的肥肉，把身体练的结实些。2014年8月份尝试了第一次马拉松，9月份又跑了一次半马比赛。在又跑了几次马拉松比赛后，对越野跑开始感兴趣。参加了龙山30公里越野，耗时8小时踩着关门时间完成。但是2014年12月份多踢球的时候不慎右膝扭伤，第二天走路一瘸一拐，差不多了养了1个半月才好。那时候没有重视起来，没去医院检查。这修养的一个半月直接导致我体重增长了10斤。1个半月后感觉伤势已无大碍，就又开始跑步。参加了平乐金鸡谷20公里越野，耗时3个半小时。3月中旬的重庆马拉松原定4小时跑完，但准备不充分再加上赛场上出了状况，第26公里跑崩，接下来的十几公里都是走完的，耗时5小时14分。3月30日爱江山龙山越野赛参加了60公里组，爬到山顶后一路下坡，但是跑不起来，自己技术不行+膝盖痛，只能走着。走到55公里处被关门。</p>

<p>右膝平时走路没问题，但是运动量一超过20公里就有感觉，再多的话就无法跑动了。我以为恢复的不彻底，所以也没太在意。接下来离大连100只剩下18天了。进入4月份以后事情比较多，训练只能利用晚上的时间，大概晚上10点多在小区内开始跑，跑完12公里收工。连续训练了几天，速度虽然没练上来，但是好歹是找回了点状态。</p>

<p>为了防止右膝出状况，我还特意买了副护膝给右膝，好在路跑还行，右膝反应不大。</p>

<p>比赛的日子临近了，4月17号坐上了去大连的飞机，中午达到。入住酒店后领了跑手包，去海边逛了逛。晚上回来把第二天要穿的东西都码好，省的早上起来手忙脚乱。</p>

<p><img src="http://www.huangbowen.net/images/IMG_1938.JPG" width="600"></p>

<p>这次大连100前50公里我的装备是：</p>

<ul>
<li><p>2条魔术头巾</p></li>
<li><p>李宁跑步T恤</p></li>
<li><p>萨洛蒙跑步背包（包内皮肤风衣一件，能量胶3个，能量棒一个，盐丸三个，泡腾片半盒，手机一部）</p></li>
<li><p>TomTom运动手表</p></li>
<li><p>骑行手套</p></li>
<li><p>迪卡侬紧身7分裤</p></li>
<li><p>迪卡侬护膝（只是右膝）</p></li>
<li><p>迪卡侬护腿（两只）</p></li>
<li><p>泰尼卡闪电2越野跑鞋</p></li>
</ul>


<p>事实证明这套装备还是挺给力的，性价比高（没办法，穷，只能用迪卡侬几十块的东西）。</p>

<p><img src="http://www.huangbowen.net/images/IMG_1936.JPG" width="600"></p>

<p>第二天早上4点起床，吃完早饭排空后来到起跑点，调整片刻做了热身活动后，比赛正式开始。刚开始我维持平时正常的配速，6分左右，下坡时稍快。跑了几公里公路后即开始上山。山上的路也好跑，也是公路。我感觉状态好，想在前面多争取些时间，所以上坡也是慢跑上去。下坡则利用新学的跑步技巧，飞一般的奔下去。即双手略微张开，身体稍微前倾，小步幅，大步频，又快又稳。没过多久就到了补给点1，没感觉多累。过了补给点1以后路开始野了。有羊肠小道，防火道，台阶等。我感觉状态还维持的不错。很快补给点2也轻松跑过。照这样下去拿银海星都没问题。</p>

<p>但是接下来右膝开始有反应了，不得不调整节奏，变为上坡走，下坡和平路跑的策略。到了补给点3，时间花费的不多，自己很满意。从补给点3向补给点4进发的过程中，发觉下坡跑也快不起来了，只好又开始调整为上坡走，下坡慢跑，平路跑。慢慢的超我的人越来越多。好不容易到了补给点4以后，我在站里休息了40分钟才走，不像前几个补给站总共耽误的时间加起来也没有10分钟。我吃了2桶泡面，2碗粥，若干水果。待身体恢复的差不多了才继续进发。补给站4到补给站5有12.5公里。我原计划2个小时到2个小时半到达。但是膝盖越来越痛，基本只能走了，想跑根本跑步起来，跑几步就只能停下来。</p>

<p>这样花了3个小时10分钟我才到补给站5. 在补给站我没什么胃口，只喝了点粥，然后拿上头灯，穿上外套和裤子。已经下午5点了，大连晚上的日子是非常冷的。补给站5到6只有6.5公里，总爬升才200多米。正常情况下不到1小时就可完成。但是我完全跑不起来，磨磨蹭蹭用了1小时半才搞定。到了补给站6天已经完全黑了。还好在路上遇到了一个北京来的哥们，也是膝盖受伤，我们一起前行。这个哥们上个月刚完成了杭州100，毅力惊人。我们一起从补给站6向7进发，这段路是整个赛道中最难的路，11公里，总爬升860多米。按照我们目前行进的速度，乐观点3个小时搞完，不乐观的话需要4个小时。</p>

<p>前半程我们的速度还可以，虽然一直在走，但走的不算很慢。但是过半后，膝盖痛的都无法伸直了。我捡了一根棍子当做拐杖，减轻些压力。已经晚上10点多了，望着面前黑漆漆的裙身，麻木而机械的走着。内心在思考要不要退赛。不退赛的话，膝盖实在受不了了，即使撑到补给站9，还有8公里近800多爬升的魔鬼路段等着我，以我现在的状态很难完成。退赛的话，这对我来说是个巨大的打击。能够站在100公里赛道上的人，意志力都是非常强大的，而我却被自己打败。</p>

<p>最后还是决定退赛了，我们走到补给站7，给工作人员说明退赛，然后交通车把我们拉回了起点。在路上可以看到很多人还在坚持比赛，等待他们的是还有8个小时战斗。而我却在第72公里处退出了这场战斗。</p>

<p>回到酒店澡都没力气洗就睡了。半夜槟郎哥完赛归来，拿到了银海星。第二天我睡到10点才起来，得知成都来的4个人三个参加百公里的都因伤退赛了，只有参加50公里的米儿完赛，虽然也受伤了。</p>

<p><img src="http://www.huangbowen.net/images/IMG_1948.JPG" width="600"></p>

<p>这次没有拿到海星，很遗憾。总结原因如下：</p>

<ol>
<li><p>右膝长距离运动后反应很大，需要去医院检查下，是否是那次受伤有半月板撕裂之类的；</p></li>
<li><p>长距离LSD拉的少，后半程跑不起来体力不够也是原因之一；</p></li>
<li><p>前半程冲的过猛，可能也是早早受伤的原因，欲速则不达。</p></li>
</ol>


<p>当在比赛途中，身体在地狱旅行时，我一直在想自己吃饱了撑的来参加这么自虐的比赛，下次绝对不参加了，好好在家里逗孩子多好。但是比赛完毕后，无论是成功或者失败，我又想马上投入另一场战斗中，开始思考下一场比赛是啥时候。</p>

<p>我决定这周先去检查一下膝盖，看看是否膝盖有损伤。根据医生的检查结果，再制定接下来的训练计划。估计至少半年后再挑战百公里了，可以选择大理100或者HK100，难度相对小些。当然，前提是要保证身体无伤痛+大量的训练。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[驱动力来自哪里-献给迷茫的程序员]]></title>
    <link href="http://www.huangbowen.net/blog/2015/04/21/drive-yourself/"/>
    <updated>2015-04-21T17:46:16+08:00</updated>
    <id>http://www.huangbowen.net/blog/2015/04/21/drive-yourself</id>
    <content type="html"><![CDATA[<p>驱动你做一件事情的动力来源是什么？不知道大家想过这个问题没有。一般人可能会想到两种驱动力。</p>

<!-- more -->


<p><strong>一种是生存本能带来的驱动力，即生物性驱动力。</strong>比如每天要吃饭、睡觉、上厕所，长大了要恋爱、结婚等。这种驱动力保证我们能够生存在这个世界上，是一种原始的驱动力。</p>

<p><strong>另一种是奖励或者惩罚带来的驱动力，即外在动机。</strong>比如老板承诺工作干的好有奖金，我们就努力干活。如果上班迟到会罚款，我们会早起等。这种驱动力会改变人的行为，使其多做鼓励的事情，少做禁止的事情。</p>

<p>如果只依靠这两种驱动力，那么你的人生会变得精彩吗？很难。为什么那？第一种驱动力只解决了你的生存问题；而第二种驱动力则约束了你的行为。你不想上班，但不得不上班。一旦你做某件事情获得了奖励，你就会对奖励上瘾。而当你认为你得到的奖励与你的付出不成正比时，你的行为就会松懈下来。</p>

<p>要想保持第二种驱动力长期有效，那么就需要管理者具有相当高的水平，比如确保内部公平和外部公平，报酬要高于平均水平，考核标准衡量因素要广。咱们作为打工的，能碰到这样的领导那肯定是烧了高香。能有10%的领导都做到以上几点就算行了大运了。</p>

<p>那么除了这两种驱动力，还有没有第三种驱动力那？答案是有。<strong>那就是内在动机，即完成某件事情带来的成就感和愉悦感。</strong>比如你打LOL，完成了5杀，那感觉嗨翻天了。还有你去跑步，第一次不间断跑了10公里，完成后的感觉肯定会非常奇妙。你修复了一个存在已久的软件故障，那么今天就会感觉很充实。这种没有人主动给你奖励或惩罚的事情你却干的津津有味。为了练好LOL中的大局观，你研习了数千盘比赛录像。为了能够跑的更远，你查阅了很多跑步相关的教程、书籍。为了修复你遇到的bug，你不惜翻墙来搜集相关资料。</p>

<p>如果你能驾驭这第三种驱动力，那么恭喜你，你的人生会一直前进。关键在于，如何驾驭这第三种驱动力那？你首先要问你自己一个问题，“我真的喜欢编程吗？我能确定我当程序员不仅是为了养家糊口，而是为了实现自己的人生价值吗？”  这一点非常重要，它决定了你是否能利用第三种驱动力来促使你成长。如果你答案是为了养家糊口，那么很可能你成为不了一个优秀的程序员，并且在这条路上你越走越疲倦；如果你的答案是真心喜欢编程，那也很可能说明不了什么问题，除非你每天都在主动的学习和进步。</p>

<p><strong>在编程的路上想要利用第三种驱动力，请先忘却掉它可能给你带来的奖励，而是切实的学习知识，充实自己，奖励只是你进步途中的副产品。</strong>如果你做一件事情先想着它有没有价值，会不会给你带来收益，那么你还是在利用第二种驱动力。能不能带来收益在你当时的环境中你是很难看出来的。举个例子，AngularJs刚面世的时候，我一个同事对其非常感兴趣，研读了很多相关的资料，并积极试用，虽然那时候它极不成熟。在那个时间点其实看不出来它会带来什么收益，说不定过几个月AngularJs框架就会销声匿迹。但是几年下来，我这个同事已经是国内AngularJs的专家了，社区里影响力很大，目前还在写一本关于它的书籍。</p>

<p>第三种驱动力，内在动力，其实就是自主性。<strong>当你做些不是工作范畴之内的事情时，你反而离成功更近。</strong>再拿编程来说，很多大牛在上班时间外，会写一些博客，参加一些社区聚会，翻译或者写书。做这些事情都是靠内在动力驱动的。所以他们成了大牛，而按部就班的程序员依然时普通的程序员。当你自发想做一些事情时，你无疑已经领先了很多人一大步，因为他们都在原地踏步。</p>

<p><strong>第三种驱动力是一种良性循环，很容易就可以把人变得乐观，积极向上，感觉生活充满希望。</strong>善于驾驭这种能力的人会在生活和工作中都使用它，而工作和生活统一起来，不再相互冲突。拿我来说，我平时喜欢跑步，从一次只能10公里，跑到了一次可以跑15公里，20公里，42公里&hellip;.直到上周花了17小时跑了72公里山路，本来计划跑100公里的，但是膝盖受伤，不得不终止。没人强迫我这样跑，我跑完了也没有任何金钱上的奖励，而且跑步本身其实也是蛮花钱的。我为什么这么喜欢跑，那就是一种挑战自己的精神，看看自己的极限在哪里。我不和别人比，只和自己比。<strong>只要能证明今天的自己比昨天的自己更优秀，那我今天就没有白过。</strong>这种精神也会传染到我的工作中。工作中再大的困难都不算什么，别人能做到我也能。即使现在做不到，那么也会主动的寻找差距去弥补，去提升。如果你能从早上6点跑到第二天早上8点（我参加的比赛关门时间是26小时，从早上6点到第二天早上8点，我认识的好几个人都跑了25个多小时，而我在跑了17小时候因伤退赛），那么你会发现很多以前对你来说不可能的事情都不再那么困难。</p>

<p>好了，希望大家都能更好的利用第三种驱动力，即内在动机。<strong>这种驱动力不仅要用在工作上，更要用在生活上。有了孩子以后，我认为生活比工作更重要，工作只是为了创造更好的生活。</strong></p>

<p>希望大家都能快乐、开心、充实的过好每一天。</p>
]]></content>
  </entry>
  
</feed>
